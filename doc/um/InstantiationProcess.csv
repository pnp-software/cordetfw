ID|Title|SpecificationStep|Sect|ImplementationStep|MasterAP|SlaveOneAP|SlaveTwoAP
1|Identify Target Application|Identify the application for which the framework is being instantiated. ||The Application Identifier is specified in \texttt{CrFwUserConstants.h}.|The identifier of the Master Application is 1.|The identifier of the Slave 1 Application is 2.|The identifier of the Slave 2 Application is 3.
2|Identify Service Users |Identify the users of the services provided by the target application. Each service user is identified through its Application Identifier.  ||The service user identifiers are used to define the sources of incoming commands (InCommands) for the application in \texttt{CrFwInStreamUserPar.h} and the destination of out-going reports (OutCompnents) in \texttt{CrFwOutStreamUserPar.h}.|The Master Application does not provide any services.|The Slave 1 Application provides one service (Temperature Monitoring Service) to the Master Application.|The Slave 2 Application provides one service (Temperature Monitoring Service) to the Master Application.
3|Identify Service Providers |Identify the providers of the services used by the target application. Each service provider is identified through its Application Identifier. ||The service provider identifiers are used to define the sources of incoming reports (InReports) for the application in \texttt{CrFwInStreamUserPar.h} and the destination of out-going commands (OutCompnents) in \texttt{CrFwOutStreamUserPar.h}.|The Master Application uses one service (Temperature Monitoring Service) provided by the two Slave Applications.|The Slave 1 Application does not use any services provided by other applications.|The Slave 2 Application does not use any services provided by other applications.
4|Define Used Services |Define the services which are used by the target application. Each service is defined through: its identifier (the "service type"); a description of the purpose of the service; the external entity which provides the service; the commands and reports which implement the service. ||The range of services used by the application is defined in \texttt{CrFwInFactoryUserPar.h} and \texttt{CrFwOutFactoryUserPar.h}. Also, a list of services supported by the application is defined in \texttt{CrFwOutRegistryUserPar.h}.|The Master Application uses the Temperature Monitoring Service (type identifier: 64) with three commands (sub-type identifiers: 1, 2 and 3) to enable monitoring, disable monitoring and to set the monitoring limit; and one report (sub-type identifier: 4) to report temperature limit violations. The service is provided by each of the two slave applications.|The Slave 1 Application does not use any services provided by other applications.|The Slave 2 Application does not use any services provided by other applications.
5|Define Provided Services |Define the services which are provided by the target application. Each service is defined through: its identifier (the "service type"); a description of the purpose of the service; the external entity which uses the service; the commands and reports which implement the service.  ||The range of services provided by the application is defined in \texttt{CrFwInFactoryUserPar.h} and \texttt{CrFwOutFactoryUserPar.h}. Also, a list of services supported by the application is defined in \texttt{CrFwOutRegistryUserPar.h}.|The Master Application does not provide any services.|The Slave 1 Application provides the Temperature Monitoring Service (type identifier: 64) with three commands (sub-type identifiers: 1, 2 and 3) to enable monitoring, disable monitoring and to set the monitoring limit; and one report (sub-type identifier: 4) to report temperature limit violations. The service is provided by each of the two slave applications.|The Slave 2 Application provides the Temperature Monitoring Service (type identifier: 64) with three commands (sub-type identifiers: 1, 2 and 3) to enable monitoring, disable monitoring and to set the monitoring limit; and one report (sub-type identifier: 4) to report temperature limit violations. The service is provided by each of the two slave applications.
6|Identify Re-Routing Capabilities |Define the applications to which incoming packets received must be re-routed. |\ref{sec:PcktInterface}|The re-routing information is defined in the re-routing function which is provided to the framework as a function pointer in \texttt{CrFwInLoaderUserPar.h} and for which two defaults are provided by the InLoader component. Also, re-routing contributes to the definition of InStreams and OutStreams (InStreams are required to receive re-routed packets and OutStreams are required to forward them).|The Master Application does not have any re-routing capabilities. It uses the default implementations of the re-routing function \texttt{CrFwInLoaderDefNoRerouting}.|The Slave 1 Application re-routes packets exchanges betweeb the Master Application and the Slave 2 Application. It uses the default implementation of the re-routing function \texttt{CrFwInLoaderDefGetReroutingDestination} and has an InStream and an OutStream to handle re-routed packet to and from the Slave 2 Application.|The Slave 2 Application does not have any re-routing capabilities. It uses the default implementations of the re-routing function \texttt{CrFwInLoaderDefNoRerouting}.
7|Define Incoming Commands|For each provided service, define the commands which implement it (i.e the commands which the application must be able to receive and process) in terms of: their attributes, their acceptance and ready checks, their start action, progress action, termination action, and abort action.|\ref{sec:InCommand}|The detailed definition of the incoming commands is done in \texttt{CrFwInFactoryUserPar.h}. Also, for each command, a C-module must be provided which implements the functions encapsulating the command actions and checks. See module \texttt{CrFwInCmdSample1} for an example.|The Master Application does not handle any incoming commands.|The Slave 1 Application handles the following incoming commands for the Temperature Monitoring Service: (a) Enable Temperature Monitoring (no attributes; default checks; and all actions default except the Progress Action); (b) Disable Temperature Monitoring (no attributes; default checks; and all actions default except the Progress Action); (c) Set Temperature Limit (one attribute representing the temperature limit; default checks; and all actions default except the Progress Action). The three commands are defined in \texttt{CrDaTempMonitor}.|The Slave 2 Application handles the following incoming commands for the Temperature Monitoring Service: (a) Enable Temperature Monitoring (no attributes; default checks; and all actions default except the Progress Action); (b) Disable Temperature Monitoring (no attributes; default checks; and all actions default except the Progress Action); (c) Set Temperature Limit (one attribute representing the temperature limit; default checks; and all actions default except the Progress Action). The three commands are defined in \texttt{CrDaTempMonitor}.
8|Define Incoming Reports |For each used service, define the reports which implement it (i.e. the reports which the application must be able to receive and process) in terms of: their attributes, their acceptance check, and their update action.  |\ref{sec:InReport}|The detailed definition of the incoming reports is done in \texttt{CrFwInFactoryUserPar.h}. Also, for each report, a C-module must be provided which implements the functions encapsulating the report actions and checks. See module \texttt{CrFwInRepSample1} for an example.|The Master Application handles one incoming report for the Temperature Monitoring Service (Report Temperature Limit Violation) with the following charateristics: (a) one attribute representing the temperature measurement; (b) acceptance check which always returns true; (c) udpate action which prints a message to stdout. The report is defined in \texttt{CrMaInRepTempViolation}.  |The Slave 1 Application does not handle any incoming commands.|The Slave 2 Application does not handle any incoming commands.
9|Define Outgoing Commands and Reports|For each provided service, define the reports which implement it and for each used service, define the commands which implement it in terms of: their attributes, their enable check, and their ready, and repeat check and their update action.|\ref{sec:OutComponent}|The detailed definition of the out-going commands and reports is done in \texttt{CrFwOutFactoryUserPar.h}. Also, for out-going reports or commands which do not use the default implementations of the OutComponent adaptation points, a C-module must be provided which implements the functions encapsulating the report or command actions and checks. See module \texttt{CrFwOutCmpSample1} for an example.|The Master Application handles three out-going commands for the Temperature Monitoring Service for the slave applications: (a) Enable Temperature Monitoring (no attributes; default enable and ready checks); (b) Disable Temperature Monitoring (no attributes; default enable, ready and repeat checks); (c) Set Temperature Limit (one attribute representing the temperature limit; default enable and ready checks). The commands are defined in: \texttt{CrMaOutCmpEnableDisable} and \texttt{CrMaOutCmpSetTempLimit}. The Update Action is not used (the commands are configured through dedicated functions) and therefore its default implementation is used. The repeat check always returns 'no repeat'.|The Slave 1 Application handles one out-going report (Report Temperature Limit Violation) with one attribute representing the temperature measurement and default enable, ready and repeat checks. The report is defined in: \texttt{CrDaOutCmpTempViolation}. The Update Action is not used (the report is configured through a dedicated functions) and therefore its default implementation is used. The repeat check always returns 'no repeat'.|The Slave 2 Application handles one out-going report (Report Temperature Limit Violation) with one attribute representing the temperature measurement and default enable, ready and repeat checks. The report is defined in: \texttt{CrDaOutCmpTempViolation}. The Update Action is not used (the report is configured through a dedicated functions) and therefore its default implementation is used. The repeat check always returns 'no repeat'.
10|Assign Commands and Reports to Groups|Define command and report groups and define rules for assigning commands and reports to groups.||The definition of the assignment rules is done in the implementation of the getter and setter functions for the group attribute in module \texttt{CrFwPckt}. |The default assignment is used which allocates all commands and reports to the same group.|The default assignment is used which allocates all commands and reports to the same group.|The default assignment is used which allocates all commands and reports to the same group.
11|Define Command and Report Layout|For each command and report which can be either generated or received by the target application, define the layout of the packet which carries it.|\ref{sec:PcktImpl}|The packet layout is implicitly implemented in the setter and getter functions of the \texttt{CrFwPckt.h} interface. The application developer must provide a complete implementation for this interface. A stub implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.|For the header part of a packet, the same layout as in the stub implementation of \texttt{CrFwPckt.h} in \texttt{/cr/src/crConfigTestSuite} is used. The temperature attribute is stored as an unsigned integer in the first parameter byte. All packets have a fixed length of 100 bytes.|For the header part of a packet, the same layout as in the stub implementation of \texttt{CrFwPckt.h} in \texttt{/cr/src/crConfigTestSuite} is used. The temperature attribute is stored as an unsigned integer in the first parameter byte. All packets have a fixed length of 100 bytes.|For the header part of a packet, the same layout as in the stub implementation of \texttt{CrFwPckt.h} in \texttt{/cr/src/crConfigTestSuite} is used. The temperature attribute is stored as an unsigned integer in the first parameter byte. All packets have a fixed length of 100 bytes.
12|Define Packet Allocation Policy|Define the allocation policy for the packets which the application creates when it receives a command or report.|\ref{sec:PcktImpl}|The packet allocation policy is implemented in the \texttt{make} function of the \texttt{CrFwPckt.h} interface. The application developer must provide a complete implementation for this interface. A stub implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.|The Master Application uses the default packet allocation policy of the stub implementation of  \texttt{CrFwPckt.h} in \texttt{/cr/src/crConfigTestSuite}.|The Slave 1 Application uses the default packet allocation policy of the stub implementation of  \texttt{CrFwPckt.h} in \texttt{/cr/src/crConfigTestSuite}.|The Slave 2 Application uses the default packet allocation policy of the stub implementation of  \texttt{CrFwPckt.h} in \texttt{/cr/src/crConfigTestSuite}.
13|Define Command and Report Capacity|Define: the maximum number of incoming commands which the target application can hold at any given time; the maximum number of incoming reports which the target application can hold at any given time; and the maximum number of outgoing commands or reports which the application can hold at any given time. ||The capacities for incoming commands and reports are defined as \texttt{\#DEFINE} constants in \texttt{CrFwInFactoryUserPar.h}. The capacity for out-going commands and reports is defined as a \texttt{\#DEFINE} constant in \texttt{CrFwOutFactoryUserPar.h}.|All capacities are equal to 10.|All capacities are equal to 10.|All capacities are equal to 10.
14|Define Application Modes|Define the sub-states in the states of the Application State Machine.|\ref{sec:AppStartUp}|For each set of sub-states, a state machine implementing them is defined which is then embedded in one of the states of the Application State Machine. The embedded state machines are defined in \texttt{CrFwAppSmUserApp.h}. |No sub-states are defined.|No sub-states are defined.|No sub-states are defined.
15|Define Incoming Middleware Interface|Define the interface to the middleware which is responsible for receiving the commands and reports for the target application.|\ref{sec:InStream}|For each source of commands or reports, one InStream is defined. The size of the InStream packet queues and the pointers to the functions which implement the InStream operations are defined in \texttt{CrFwInStreamUserPar.h}. Also, for each InStream a C module must be defined which implements the InStream functions. A test stub is provided in \texttt{CrFwInStreamStub}.|The Master Application has a physical connection to the Slave 1 Application. On the Master Application side, this connection  is implemented as a TCL client socket. The interface to the socket is defined in \texttt{CrDaClientSocket}. The Master Application instantiates two InStreams to receive packets from the two slave applications.|The Slave 1 Application has a physical connection to the Slave 2 Application and to the Master Application. On the Slave 1 Application side, these connections are implemented as a TCL server socket. The interface to the socket is defined in \texttt{CrDaServerSocket}. The Slave 1 Application instantiates two InStreams to receive packets from the Master Application and from the Slave 2 Application (for which it acts as a re-routing application).|The Slave 2 Application has a physical connection to the Slave 1 Application. On the Slave 2 Application side, this connection  is implemented as a TCL client socket. The interface to the socket is defined in \texttt{CrDaClientSocket}.  The Slave 2 Application instantiates one InStream to receive packets from the Master Application.
16|Define Out-Going Middleware Interface|Define the interface to the middleware which is responsible for sending the commands and reports originating in the target application.|\ref{sec:OutStream}|For each command or report destination, one OutStream is defined. The size of the OutStream packet queues and the pointers to the functions which implement the OutStream operations are defined in \texttt{CrFwOutStreamUserPar.h}. Also, for each OutStream a C module must be defined which implements the OutStream functions. A test stub is provided in \texttt{CrFwOutStreamStub}.|The Master Application has a physical connection to the Slave 1 Application. On the Master Application side, this connection  is implemented as a TCL client socket. The interface to the socket is defined in \texttt{CrDaClientSocket}. The Master Application instantiates two OutStreams to send packets to the two slave applications.|The Slave 1 Application has a physical connection to the Slave 2 Application and to the Master Application. On the Slave 1 Application side, these connections are implemented as a TCL server socket. The interface to the socket is defined in \texttt{CrDaServerSocket}. The Slave 1 Application instantiates two OutStreams to send packets to the Master Application and to the Slave 2 Application (for which it acts as a re-routing application).|The Slave 2 Application has a physical connection to the Slave 1 Application. On the Slave 2 Application side, this connection  is implemented as a TCL client socket. The interface to the socket is defined in \texttt{CrDaClientSocket}.  The Slave 2 Application instantiates one OutStream to send packets to the Master Application.
17|Define InManagers|Define the number of InManagers and the size of their Pending Command/Report Lists (PCRLs).||These items are defined as \texttt{\#DEFINE} constants in \texttt{CrFwInManagerUserPar.h}|The Master Application only needs one InManager for incoming reports. However, in order to re-use the default implementation of the InLoader (which sends incoming reports to InManager 2), two InManagers are defined and the first one remains unused. The size of their PCRLs are, respectively, 1 and 20. The value of 20 is equal to the sum of the sizes of the packet queues of the two InStreams of the Master Application..|The Slave 1 Application defines one InManager to handle its incoming commands. The size of its PCRL is 10. This matches the size of the packet queues in the InStreams of the Slave 1 Application.|The Slave 2 Application defines one InManager to handle its incoming commands. The size of its PCRL is 10. This matches the size of the packet queues in the InStreams of the Slave 2 Application.
18|Define InManager Selection Function|Define the logic to select the InManager where an incoming command or report is loaded.|\ref{sec:InLoader}|A pointer to this function is defined in \texttt{CrFwInLoaderUserPar.h}. A default implementation is provided by the InLoader (see \texttt{CrFwInLoader.h}).|The Master Application uses the default implementation of the InManager selection function.|The Slave 1 Application uses the default implementation of the InManager selection function.|The Slave 2 Application uses the default implementation of the InManager selection function.
19|Define InRegistry|Define the maximum number of commands and reports which can be tracked by the InRegistry.||This item is defined as a \texttt{\#DEFINE} constant in \texttt{CrFwInRegsitryUserPar.h}.|The Master Application sets the maximum number of tracked commands/reports to 64.|The Slave 1 Application sets the maximum number of tracked commands/reports to 64.|The Slave 2 Application sets the maximum number of tracked commands/reports to 64.
20|Define OutManagers|Define the number of OutManagers and the size of their Pending OutComponent Lists (POCLs).||These items are defined as \texttt{\#DEFINE} constants in \texttt{CrFwOutManagerUserPar.h}.|The Master Application defines one OutManager to handle out-going commands. The size of its POCL is 10, namely the same as the size of the packet queue of its OutStreams.|The Slave 1 Application defines one OutManager to handle out-going commands. The size of its POCL is 10, namely the same as the size of the packet queue of its OutStreams.|The Slave 2 Application defines one OutManager to handle out-going commands. The size of its POCL is 10, namely the same as the size of the packet queue of its OutStream.
21|Define OutManager Selection Function|Define the logic to select the OutManager where an out-going command or report is loaded.|\ref{sec:OutLoader}|A pointer to this function is defined in \texttt{CrFwOutLoaderUserPar.h}. A default implementation is provided by the OutLoader (see \texttt{CrFwOutLoader.h}).|The Master Application has only one OutManager and therefore uses the default implementation of the OutManager Selection Function.|The Slave 1 Application has only one OutManager and therefore uses the default implementation of the OutManager Selection Function.|The Slave 2 Application has only one OutManager and therefore uses the default implementation of the OutManager Selection Function.
22|Define OutRegistry|Define the maximum number of commands and reports which can be tracked by the OutRegistry.||This item is defined as a \texttt{\#DEFINE} constant in \texttt{CrFwOutRegistryUserPar.h}.|The Master Application sets the maximum number of tracked commands/reports to 64.|The Slave 1 Application sets the maximum number of tracked commands/reports to 64.|The Slave 2 Application sets the maximum number of tracked commands/reports to 64.
23|Define Start-Up Procedure|Define the start-up procedure for the application. This in particular includes the sequence in which framework components are instantiated, initialized and configured.|\ref{sec:AppStartUp}|Implement the Application Start-Up Procedure by providing an implementation for \texttt{CrFwAppStartUpProc.h}. A test stub is provided in \texttt{CrFwAppStartUpProc.c}.|The Master Application uses the default Start-Up Procedure which does not take any action. Start-up actions are coded in the \texttt{main} program.|The Slave 1 Application uses the default Start-Up Procedure. Start-up actions are coded in the \texttt{main} program.|The Slave 2 Application uses the default Start-Up Procedure. Start-up actions are coded in the \texttt{main} program.
24|Define Reset Procedure|Define the reset procedure for the application. This in particular includes the sequence in which framework components are reset.|\ref{sec:AppStartUp}|Implement the Application Reset Procedure by providing an implementation for \texttt{CrFwAppResetProc.h}. A test stub is provided in \texttt{CrFwAppResetProc.c}.|The Master Application uses the default Reset Procedure which does not take any action. No reset functionality is provided by the Master Application.|The Slave 1 Application uses the default Reset Procedure which does not take any action. No reset functionality is provided by the Slave 1 Application.|The Slave 2 Application uses the default Reset Procedure which does not take any action. No reset functionality is provided by the Slave 2 Application.
25|Define Shutdown Procedure|Define the shutdown procedure for the application. This in particular includes the sequence in which framework components are shutdown.|\ref{sec:AppStartUp}|Implement the Application Shutdown Procedure by providing an implementation for \texttt{CrFwAppShutdownProc.h}. A test stub is provided in \texttt{CrFwAppShutdownProc.c}.|The Master Application uses the default Shutdown Procedure which does not take any action. No shutdown functionality is provided by the Master Application.|The Slave 1 Application uses the default Shutdown Procedure which does not take any action. No shutdown functionality is provided by the Master Application.|The Slave 2 Application uses the default Shutdown Procedure which does not take any action. No shutdown functionality is provided by the Master Application.
26|Define Time Interface|Define the means through which the current time is acquired. This is needed for time-stamping out-going commands and reports in the OutStream.||The time acquisition interface is defined in \texttt{CrFwTime.h}. The application developer must provide a complete implementation for this interface. A stub implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.|The Master Application does not provide any realistic time function and uses the same stub implementation as in \texttt{/cr/src/crConfigTestSuite}.|The Slave 1 Application does not provide any realistic time function and uses the same stub implementation as in \texttt{/cr/src/crConfigTestSuite}.|The Slave 2 Application does not provide any realistic time function and uses the same stub implementation as in \texttt{/cr/src/crConfigTestSuite}.
27|Define Error Reporting Interface|Define the response to the generation of error reports.||The respone to error reports is defined in \texttt{CrFwRepErr.h}. The application developer must provide a complete implementation for this interface. A test implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.|The Master Application implements  \texttt{CrFwRepErr.h} to write an error message to stdout.|The Slave 1 Application implements  \texttt{CrFwRepErr.h} to write an error message to stdout.|The Slave 2 Application implements  \texttt{CrFwRepErr.h} to write an error message to stdout.
28|Define InCommand Outcome Reporting|Define the means through which the outcome of the processing of incoming commands is reported. ||The respone to the reports of InCommand outcomes is defined in \texttt{CrFwRepInCmdOutcome.h}. The application developer must provide a complete implementation for this interface. A test implementation is provided in the configuration directory \texttt{/cr/src/crConfigTestSuite}.|The Master Application implements  \texttt{CrFwRepInCmdOutcome.h} to write a command start acknowledge message to stdout. The implementation assumes that command progress, termination and abort do not need to be acknowledged.|The Slave 1 Application implements  \texttt{CrFwRepInCmdOutcome.h} to write a command start acknowledge message to stdout. The implementation assumes that command progress, termination and abort do not need to be acknowledged.|The Slave 2 Application implements  \texttt{CrFwRepInCmdOutcome.h} to write a command start acknowledge message to stdout. The implementation assumes that command progress, termination and abort do not need to be acknowledged.
29|Define Primitive Types|Define the range of the primitive types used by the framework components. The driver for this definition is the need to optimize the memory footprint of the application.||The primitive types are defined through \texttt{typedef}'s in \texttt{CrFwUserConstants.h}. Application developers can override the default definitions in this file (but note that, in most cases, the default definitions should be adequate).|The Master Application uses the default definition of the primitive types.|The Slave 1 Application uses the default definition of the primitive types.|The Slave 2 Application uses the default definition of the primitive types.
