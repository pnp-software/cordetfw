\documentclass{pnp_article}

\begin{document}

\SetDocIssue{4}
\SetDocRefNumber{PP-DF-COR-0002}
\SetDocTitle{The CORDET Framework}
\SetDocSubtitle{Definition}
\SetDocAuthor{Alessandro Pasetti}
\SetCheckedBy{n.a.}
\maketitle

% =======================================================================
%\listofchanges
\tableofcontents
\listoffigures
\listoftables

%---------------------------------------------
% Define Environment for Requirement Tables 
% Par #1: The string identifying the requirement category
% Par #2: The table caption
%---------------------------------------------
\newenvironment{crReq}[2]
{
\pnpcsvtable[filter equal={\Domain}{#1}]{|l|p{11.8cm}|}{#2}{tab:Req-#1}{\textbf{Req. ID} & \textbf{Requirement Text}}{CrFwRequirement.csv}{\Domain-\Name/\Kind & \textit{\Text}}
}

%---------------------------------------------
% Define Environment for Adaptation Point Tables 
% Par #1: The string identifying the category to which the AP applies
% Par #2: The table caption
%---------------------------------------------
\newenvironment{crAp}[2]
{
\pnpcsvtable[filter equal={\Domain}{#1}]{|l|p{4.7cm}|p{6.9cm}|}{#2}{tab:AP-#1}{\textbf{AP ID} & \textbf{Adaptation Point} & \textbf{Default Value}}{CrFwAdaptPoint.csv}{\Domain-\Name & \Title  & \DefaultValue}
}

% changes in issue 2 of UM and REQ and issue 3 of Definition Document
\newcommand{\chgC}[1]{{\color{black}{#1}}{}} 		





%==========================================================================================
\section{Change History}

This section lists the changes made in the current revision. Changes are classified according to their type. The change type is identified in the second column in the table according to the following convention:

\begin{itemize}
\item "\textbf{E}": Editorial or stylistic change
\item "\textbf{L}": Clarification of existing text
\item "\textbf{D}": A feature present in the previous revision has been deleted
\item "\textbf{C}": A feature present in the previous revision has been changed
\item "\textbf{N}": A new feature has been introduced
\end{itemize}


\begin{longtable}{|p{1.5cm}|p{1cm}|p{8cm}|}
\caption{Changes introduced in Revision 3}  \\
\hline
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endfirsthead
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endhead
All & E & Fixed various editorials and typos \\
\hline
7.2.2 & N & Added check on conistency between length and type of InCommand or InReport \\
\hline
\end{longtable}

\begin{longtable}{|p{1.5cm}|p{1cm}|p{8cm}|}
\caption{Changes introduced in Revision 3}  \\
\hline
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endfirsthead
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endhead
All & E & Fixed editorials in text of adaptation points and requirements \\
\hline
3.5 & L & Clarified relationship between CORDET Applications and PUS Application Processes \\
\hline
3.8 & L & Added mention of use of Cordet FW on Cheops Payload \\
\hline
5.1.1 & N,C & Modified command attributes: semantics of Sequence Counter has been changed; Group attribute has been dropped; Type Counter attribute has been added (change driven by need to remain compliant with new PUS Standardof reference [PS-SP]) \\
\hline
5.2.1 & N,C & Modified report attributes: semantics of Sequence Counter has been changed; Group attribute has been dropped; Type Counter attribute has been added (change driven by need to remain compliant with new PUS Standardof reference [PS-SP]) \\
\hline
6.2 & C & Modified concept of OutStream to allow handling of packets to multiple destinations; modified concept of InStream to allow handling of packets from multiple sources \\
\hline
6.2.1 & C & Updated OutStream definition to take account of new sequence counter and type attribute logic and of the possibility to allocate multiple destinations to the same OutStream \\
\hline
6.2.1 & N & Added adaptation point OST-14 to get group of out-going packet; added adaptation point OST-15 to define association between OutStreams and packet destinations \\
\hline
6.2.2 & C & Updated InStream definition to take account of new sequence counter management logic and of the possibility to allocate multiple sources to the same InStream; added adaptation point IST-14 to define association between InStreams and packet sources \\
\hline
6.2.1 & N & Added adaptation point to get group of incoming packet \\
\hline
7.1.1 & C & Updated definition of adaptation point OCM-16 to bring it line with implementation; added adaptation point OCM-19 to cover operation to access attributes of OutComponents; added adaptation point to get current time; modified Sent Packet Procedure to show operation to get current time as an adaptation point; added adaptation point OCM-20 to get current time  \\
\hline
7.1.2 & N & Corrected statement about setting of OutComopnent's time-stamp; added adaptation point OFT-01 to cover the kinds of OutComponents supported by an application \\
\hline
7.1.4 & L,N & Modified discussion of number of OutManagers in application and added  new adaptation point OMG-09 to cover number of OutManagers \\
\hline
7.2.1 & N & Added adaptation point IFT-01 to cover the kinds of InReports and InCommands supported by an application \\
\hline
7.2.3 & C & Adaptation points ICM-18 to 20 have been moved to adaptation point IFT-01 (TBC); adaptation point ICM-21 has been extended to cover all all operations to access InCommand attributes; definition of adaptation points ICM-01, 02 and 04 has been modified to match C2 implementation of framework \\
\hline
7.2.4 & C & Adaptation point IRP-08 to 10 have been moved to adaptation point IFT-01 (TBC); adaptation point IRP-11 has been extended to cover all operations to access InCommand attributes; definition of adaptation points IRP-01, 02 and 04 has been modified to match C2 implementation of framework \\
\hline
7.2.5 & L,N & Modified discussion of number of InManagers in application and added  new adaptation point IMG-09 to cover number of InManagers \\
\hline
\end{longtable}

\begin{longtable}{|p{1.5cm}|p{1cm}|p{8cm}|}
\caption{Changes introduced in Revision 2.1}  \\
\hline
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endfirsthead
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endhead
n.a. & E & Replaced state machine and procedure diagrams to use FW Profile Models \\
\hline
n.a. & E & Requirements and adaptation points are now exported from the Cordet FW Editor \\
\hline
\end{longtable}


\begin{longtable}{|p{1.5cm}|p{1cm}|p{8cm}|}
\caption{Changes introduced in Revision 2.0}  \\
\hline
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endfirsthead
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endhead
4.1 & C & Added Progress Step Identifier attribute to commands and modifed outcomes of progress action \\
\hline
4.1.1 & N & Added CRC attribute to commands \\
\hline
4.2.1 & N & Added CRC attribute to reports \\
\hline
5.2.1 & N & Added logic to compute and set the CRC in OutComponents \\
\hline
6.2.2 & N & Added discussion of CRC check in the acceptance check of an InCommand or InReport \\
\hline
6.2.3 & C & Added management of Progress Step Identifier and modified management logic of progress action to be compatible with 2016 release of PUS Standard \\
\hline
A.2 & D & Removed empty section on the formal verification of the InStream component \\
\hline
\end{longtable}


\begin{longtable}{|p{1.5cm}|p{1cm}|p{8cm}|}
\caption{Changes introduced in Revision 1.6.1}  \\
\hline
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endfirsthead
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endhead
All & E & Fixed missing heading changes \\
\hline
\end{longtable}

\newpage
\begin{longtable}{|p{1.5cm}|p{1cm}|p{8cm}|}
\caption{Changes introduced in Revision 1.6}  \\
\hline
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endfirsthead
\rowcolor{light-gray}
\textbf{Section} & \textbf{Type} & \textbf{Description} \\
\hline\hline
\endhead
5.1.2 & E & Minor editorial changes \\
\hline
5.2.1 & E & Fixed typo  \\
\hline
5.2.2 & C & Modified destination check in Packet Collect Procedure to match the description in the text; modified InStream State Machine to explicitly cater for a polling approach where command \texttt{PacketAvailable} is sent to check whether a packet has arrived. \\
\hline
6.2.2 & E & Minor editorial changes  \\
\hline
6.2.4 & E & Fixed typo in requirement IRP-3 \\
\hline
\end{longtable}

%==========================================================================================
\section{Referenced Documents}

The documents referenced in the present document are listed in the table below.

\listofreferencedocs{\CrSp}

%==========================================================================================
\section{Introduction}
This document specifies the CORDET Framework. The CORDET Framework is a software framework for service-oriented embedded applications. 

In terms of the classical software lifecycle, the specification presented in this document is at the level of software requirements in the sense that it defines a complete and unambiguous logical model of the framework behaviour.

The next two sub-sections define the concepts of software framework (sub-section \ref{sec:SwFwConcept}) and of service-oriented application (sub-section \ref{sec:ServConcept}). 
The following sub-sections (from sub-section \ref{sec:ObjectivesOfCrFw} to sub-section \ref{sec:SpecFormat}) explain how the CORDET Framework supports the development of service-oriented applications. 
Finally sub-section \ref{sec:Heritage} describes the heritage of the CORDET Framework.

%----------------------------------------------------------------------------------------
\subsection{Software Framework Concept}\label{sec:SwFwConcept} 
\input{CrFwSwFwConcept.tex}

%----------------------------------------------------------------------------------------
\subsection{Service Concept}\label{sec:ServConcept} 
\input{CrFwServConcept.tex}
%----------------------------------------------------------------------------------------
\subsection{Objectives of CORDET Framework}\label{sec:ObjectivesOfCrFw} 

In general terms, the goal of the CORDET Framework is to foster software reusability in the development of service-oriented embedded control applications. 

With a service-oriented concept, an application is specified in terms of the services it offers to other applications and of the services it needs from other applications and the services are in turn specified by the commands and reports which implement them.

In this perspective, the CORDET Framework supports reusability in the following ways:

\begin{enumerate}
\item{} It provides a formal definition of the abstract (implementation-independent) concept of commands and reports,
\item{} It specifies the components (the CORDET Components) which implement the abstract command and report concepts and the CORDET Standard Services, and
\item{} It allows services of general applicability for a specific domain to be pre-defined and to be available as building blocks for the development of applications in that domain.
\end{enumerate}

Each of the above points is discussed in greater detail in a dedicated sub-section below. 

\subsubsection{Definition of Command and Report Concepts}\label{sec:DefCmdRepConcepts}

The first objective of the CORDET Framework is to provide a formal definition of the abstract command concept and of the abstract report concept. 

This is done by building behavioural models of commands and of reports which:

\begin{enumerate}
\item{} capture the aspects of the behaviour of commands and reports which is common to all commands and reports independently of the definition and implementation of a concrete command or report, and
\item{} identify the adaptation points where service- and implementation-specific behaviour can be added.
\end{enumerate}

An example may clarify the definition given above. 
In section \ref{sec:CmdCondChecks}, the concept of Acceptance Check for commands is introduced. 
An acceptance check is a check that is performed upon incoming commands to determine whether the command can be accepted or whether it should be rejected. 
The abstract concept of command includes the following behavioural property: “an incoming command shall be considered for execution by a service provider only if it has passed its Acceptance Check”. 
This property is part of the abstract command concept because it is common to all commands. 
The content of the Acceptance Check (i.e. the type of check that is done on a specific incoming command) is, however, not part of the abstract command concept because it depends on the concrete service to which a command belongs.

Thus, the behavioural model for commands must guarantee that a successful Acceptance Check is a pre-condition for the execution of a command and it must identify the content of the Acceptance Check as an adaptation point for the command.

Note that the definition of an abstract command and report concept allows the specification of services to be standardized and it therefore is a precondition for the second and third objectives of the CORDET Framework. 

The abstract command concept and the abstract report concept are defined in, respectively, sections \ref{sec:CmdConcept} and \ref{sec:RepConcept}.


\subsubsection{Definition of CORDET Components}\label{sec:DefCrCmp}
The second objective of the CORDET Framework is to specify the components which implement the abstract command and report concepts (the \textit{CORDET Components}). 
These components are intended for deployment in service-oriented applications. 
More specifically, the CORDET Components cover, on the service user side, the sending of commands and the reception and distribution of reports and, on the service provider side, the processing of incoming commands and the generation of reports.

The CORDET Framework only specifies the CORDET Components but does not implement them. 
The specification is, however, done using the FW Profile (see section \ref{sec:SpecFormat}) and it therefore consists of a complete behavioural model. 
An implementation could in principle be automatically generated from the model. 

The CORDET Framework defines the behavioural models for the service components. 
Multiple implementations can be derived from these models. 
All implementations are functionally equivalent (because they implement the same behavioural model) but they differ in the choice of implementation language, of implementation technology, or of other implementation-level aspects. 

Note that the CORDET components are framework-level components. 
Hence, application developers may have to specialize them further before using them. 
Two approaches are possible in this respect: (a) the application takes over an existing implementation of the CORDET components and specializes them, or (b) the application specializes the models of the CORDET Framework and then implements the specialized models.

\subsubsection{Definition of Standard Services}\label{sec:StdServ}
The third objective of the CORDET Framework is to allow sets of \textit{standard services} to be defined. 
These services are intended to cover functionalities which are common to applications within a certain domain. 
The standard services are therefore offered as building blocks for the applications in that domain: 
an application in the domain is specified and built as a combination of standard services (which are re-used) and application-specific services (which are developed for each specific application).

The standard services are defined by defining their commands and reports and the commands and reports are defined as specializations of the abstract command and report concepts (see section \ref{sec:DefCmdRepConcepts}). 
Thus, a standard service is defined by “closing” the adaptation points identified in the abstract command and report concepts.

The CORDET Framework promotes a hierarchical definition of services as illustrated in figure \ref{fig:HierarchicalDefServ}. 
At the top layer, there is the abstract definition of commands and reports. 
This definition is entirely generic and applicable to all services in all application. 
At the intermediate level, standard services are defined which capture concrete behaviour which is common to a large number of applications. 
These standard services could be defined either by the CORDET Framework itself or by organizations which identify commonalities among the applications of interest to them. 
Finally, at the bottom level, end-applications define their own services which are entirely specific to their needs. 
The application-level services may be either taken over from the standard services or they may be created as instantiations of the generic service concept (if they are entirely application-specific).

\begin{figure}[ht]
 \centering
 \includegraphics[scale=0.3,keepaspectratio=true]{HierarchicalDefServ.png}
 \caption{Hierarchical Definition of Services}
 \label{fig:HierarchicalDefServ}
\end{figure}


\subsubsection{Definition of CORDET Components}\label{sec:crComponents}
The third objective of the CORDET Framework is to specify the components which implement the abstract command and report concepts and the standard services (the \textit{CORDET Components}). These components are intended for deployment in service-oriented applications. More specifically, the CORDET Components cover, on the service user side, the sending of commands and the reception and distribution of reports and, on the service provider side, the processing of incoming commands and the generation of reports.

The CORDET Framework specifies the CORDET Components using the FW Profile (see section \ref{sec:SpecFormat}) and it therefore consists of a complete behavioural model.  

The CORDET Framework defines the behavioural models for the service components. Multiple implementations can be derived from these models. All implementations are functionally equivalent (because they implement the same behavioural model) but they differ in the choice of implementation language, of implementation technology, or of other implementation-level aspects. 

Note that the CORDET components are framework-level components. Hence, application developers may have to specialize them further before using them. Two approaches are possible in this respect: (a) the application takes over an existing implementation of the CORDET components and specializes them, or (b) the application specializes the models of the CORDET Framework and then implements the specialized models.

%-----------------------------------------------------------------------------------
\subsection{CORDET Support For Application Development}\label{sec:CrSupportForAppDev} 

The CORDET Framework supports the development of a service-oriented application in the following ways:

\begin{enumerate}
\item{} The framework standardizes the command and report concepts. 
This allows a target application to be specified in terms of standardized features.  
\item{} The framework specifies pre-defined components to implement the generic service concept. 
This allows a target application to reuse these components.  
\end{enumerate}

Note that the support described above is a specification-level reuse: the target application imports the specification of the standard services. 
Thus, the CORDET Framework simplifies the specification of a target application because it allows that application to be specified in terms of standardized features and components.

Obviously, organizations which have developed an implementation of the CORDET components or which are using a third-party implementation of the CORDET Components can extend the benefits of the CORDET approach also to the implementation level. Further benefits can be derived by applications which have defined - at specification and/or at implementation level - standard services which are useful in their domain of interest.

%------------------------------------------------------------------------------------
\subsection{Relationship To Packet Utilization Standard (PUS)}\label{sec:RelationshipToPUS}
\input{CrFwRelationshipToPUS.tex}

%-------------------------------------------------------------------------------------------
\subsection{Middleware Layer}\label{sec:MwLayer} 
\input{CrFwMwLayer.tex}

%------------------------------------------------------------------------------------
\subsection{Specification Format}\label{sec:SpecFormat} 

This document specifies the CORDET Framework. 
The framework is specified by defining its requirements. 
The requirements of the framework are of four types:

\begin{itemize}
\item{} \textit{Standard Requirements} which define a desired feature of the framework. 
They are analogous in scope and format to the user requirements of an ordinary (non-framework) software application.
\item{} \textit{Adaptation Requirement} which define the points where the framework behaviour can be extended by the application developers. 
In some cases, the definition of an adaptation point is accompanied by the definition of the default options offered by the framework for that adaptation point.  
\item{} \textit{Usage Constraint Requirements} which define the constraints on how the components offered by the framework may be used by application developers.
\item{} \textit{Property Requirements} which define behavioural properties which are guaranteed to hold on all applications which: (a) are instantiated from the framework by closing its adaptation points, and (b) comply with the framework's usage constraints.
\end{itemize}

To each framework requirement an \textit{identifier} is attached.
The requirement identifier takes the following form: x-y/t where 'x' is an acronym identifying the function to which the requirement applies; 'y' is a unique identifier within that function; and 't' identifies the requirement type. 
The type is designated by one single letter as follows: 'S' for the Standard Requirements, 'A' for the Adaptation Requirements, 'C' for the Usage Constraint Requirements and 'P' for the Property Requirements.

The specification of the framework includes a \textit{behavioural model} of the framework which describes its behaviour and identifies the adaptation points where application developers can extend this behaviour to match their requirements.  

The behavioural model of the framework is defined using the FW Profile of reference [FW-SP]. 
It therefore consists of a set of \textit{state machines} (represented as state charts) and \textit{procedures} (represented as  activity diagrams). 
Familiarity with the FW Profile is essential for a full understanding of the framework requirements.

Wherever possible, the framework requirements simply make the state machines and procedures applicable. In other words, the state charts representing state machines and the activity diagrams representing procedures are treated as normative and no attempt is made to translate them into a comprehensive set of equivalent requirements.

State machines and procedures normally imply certain behavioural properties. 
For simplicity, properties which are inherent to a single state machine or procedure are not explicitly defined in dedicated property requirements. 
Instead, a generic property requirement is stated which makes the state machine or procedure applicable. 
The properties are also described in the informal description that accompanies the requirements.

Property requirements are only stated explicitly when the property they enunciate arises from the interaction of several state machines or procedures. 
In such cases, a formal verification of the property may also be offered. 
This is normally done on a Promela model. 
The Promela models used in this document are presented in appendix \ref{sec:VerModels}.

In accordance with the FW Profile, the activity diagrams and state diagrams identify the framework adaptation points using the <<AP>> stereotype (but note that not all adaptation points are identified explicitly in activity or state diagrams). 
For convenience, all adaptation points with their default options are listed in dedicated tables. 
In most cases, the adaptation requirements simply make the items in such tables applicable. By default, the implementation mechanism for the adaptation points is left open and is not covered by this specification. 

In some cases, requirements are formulated which constrain an adaptation point to be closed at compile time (i.e. the requirement mandates the static definition of the behaviour to be associated to the adaptation point and it forbids a situation where the application dynamically – at run-time – changes this behaviour). 
 
Some of the components specified by the CORDET Framework are defined as extensions of other CORDET components. 
In such cases, the extended component is derived from the base component by either \textit{overriding} or \textit{closing} some of its adaptation points. 
A derived component overrides an adaptation point of its base component when it changes the default behaviour associated to that adaptation point (but applications can still change that behaviour). 
A derived component closes an adaptation point of its base component when it defines in a final way the behaviour associated to that adaptation point (i.e. applications can no longer change that behaviour).

%---------------------------------------------------------------------------------------
\subsection{Heritage}\label{sec:Heritage}
The service concept on which the CORDET Framework is based is the same as the service concept of the “Packet Utilization Standard” or PUS. 
The PUS is specified in reference [PS-SP] as an application-level interface standard for space-based applications. 
In spite of its origin in the space industry, the PUS is suitable for a wider range of embedded control applications and was for this reason selected as a basis for the CORDET Framework. 

The models of the CORDET Components are based on models defined in past research projects (see references [CR-AS] and [CR-CR) and on the OBS Framework Design Patterns (see reference [CR-OB]). 

An earlier version of the CORDET Framework was used as the basis for the definition and design of an industrial-quality framework for the diagnostic instruments of a major pharmaceutical company. \chgC{Version 1.0.0 was used for the implementation of the on-board software of the Cheops Satellite}. The viability of the design patterns and concepts behind the CORDET Framework is therefore demonstrated at industrial level. 

%=======================================================================================
\section{Application Start-Up and Shut-Down}\label{sec:AppStartUpAndShutdown}

This section defines the requirements applicable to the start-up and shutdown of an application instantiated from the CORDET Framework.

The start-up process is divided into two stages: \textit{initialization} and \textit{configuration}. The initialization stage covers actions which are performed only at start-up time and which cannot be repeated until the application is shutdown. The configuration stage covers actions which are performed at start-up time but which may also be performed at a later stage if there is a need to reset either the entire application or a part of it. 

In this document, the term \textit{shutdown} is used to designate the orderly shutdown of an application or component. Obviously, applications and components may also undergo an emergency shutdown. This is entirely uncontrolled and is not specified in any way by the CORDET Framework.

The start-up and shutdown processes are specified at two levels: at the level of \textit{individual components} and at the level of the \textit{entire application} which are described in, respectively, sections \ref{sec:BaseCmp} and \ref{sec:AppStartUp}.

Before they are initialized and configured, components must be \textit{instantiated}. Most components required by an application are instantiated as part of that application start-up (\textit{early component instantiation}). In some cases, components may need to be instantiated during the application's normal operation (\textit{late component instantiation}). The two forms of components instantation are discussed in section \ref{sec:CmpInst}.

%---------------------------------------------------------------------------------
\subsection{Component Instantiation}\label{sec:CmpInst}

Components may be instantiated either \textit{early} or \textit{late}. Early instantiation takes place as part of the application start-up. This is required by the logic of the \textit{Application State Machine} of section \ref{sec:AppStartUp}.

Late instantiation can take place at any time during the application's normal operation (i.e. while the \textit{Application State Machine} of section \ref{sec:AppStartUp} is in state NORMAL). 

The CORDET Framework encapsulates the late instantiation of components in \textit{factory components}. More precisely, the CORDET Framework specifies that factory components be defined for all component types which may be instantiated during normal operation (see table \ref{tab:FactoryCmp}).

The component instantiation process is entirely application-specific. 
Hence, at framework level, factory components are defined exclusively in terms of their API. A factory component is a component which offers two operations: a \texttt{Make} operation to create an instance of a component of a certain type and a \texttt{Release} operation to reclaim a component instance of that type which is no longer needed within its host application.

The \texttt{Make} operation takes as arguments the information required to instantiate and, possibly, initialize and/or configure the target component. The arguments of the \texttt{Make} operation therefore depend on the type of component to be instantiated by the factory.

The \texttt{Make} operation can either fail or succeed. If it fails (perhaps because the available resources do not allow the creation of a new command instance), it returns nothing. If it succeeds, it returns a component instance of the specified kind. Depending on the allocation policy used internally in the factory, the instantiated component may be either in state CREATED, or in state INITIALIZED, or in state CONFIGURED (see section \ref{sec:BaseCmp}). It is then the responsibility of the host application to initialize and/or configure the instantiated component.

Note that, if a failure of the \texttt{Make} operation represents an error, this must be handled by the user of the factory. The factory itself does not perform any error handling.

The \texttt{Release} operation is provided for the case of applications which wish to manage a pool of pre-allocated component instances. The operation takes the component to be released as its argument. After the release operation has been called on a component instance, that component instance must not be used again by the application. 

Table \ref{tab:FactoryCmp} lists all factory components pre-defined by the CORDET Framework. The requirements at the end of this section apply to all factory components. 
Requirements which are specific to a particular kind of factory component are defined in dedicated sections in the remainder for this document (see last column of table \ref{tab:FactoryCmp}). 

Applications may provide additional factory components if they need to instantiate application-specific components during normal operation.

\begin{longtable}{|c|p{8cm}|c|}
\caption{Factory Components Provided by CORDET Framework}\label{tab:FactoryCmp} \\
\hline
\rowcolor{light-gray}
\textbf{Name} & \textbf{Purpose of Factory Components} & {Section}\\
\hline\hline
\endfirsthead
\rowcolor{light-gray}
\textbf{Name} & \textbf{Purpose of Factory Components} & {Section}\\
\hline\hline
\endhead
OutFactory & Instantiation of OutComponents (components encapsulating an out-going command or report, see section \ref{sec:OutComponent}) & {\ref{sec:OutFactory}}\\
\hline
InFactory & Instantiation of InReports and InCommands (components encapsulating incoming reports and commands, see sections \ref{sec:InCommand} and \ref{sec:InReport}) & {\ref{sec:InFactory}}\\
\hline
\end{longtable}
 
\begin{crAp}{FAC}{Adaptation Points for Factory Components}
\end{crAp}

\begin{crReq}{FAC}{Requirements Applicable to Factory Components}
\end{crReq}



%----------------------------------------------------------------------------
\subsection{Component-Level Start-Up and Shutdown}\label{sec:BaseCmp}
The start-up and shutdown process of a CORDET component is defined by the \textit{Base State Machine} of figure \ref{fig:BaseSM}. Its logic can be summarized as follows.

\begin{figure}[ht]
 \centering
 \includegraphics[scale=0.4,keepaspectratio=true]{BaseSM.png}
 \caption{Base State Machine}
 \label{fig:BaseSM}
\end{figure}

Initially, after being instantiated, framework components are in state CREATED. 
The hosting application is then expected to provide to each component the information it needs to perform its initialization. 
The type of this information is component-specific. 
After the necessary information has been provided, the application sends an \texttt{Init} command to the component. 
The component responds by running its \textit{Initialization Procedure}. 
This procedure is responsible for initializing the component and is defined in figure  \ref{fig:InitializationPr}. 

The \textit{Initialization Procedure} is based on an \textit{Initialization Check} and an \textit{Initialization Action}. 
Both the check and the action are adaptation points which must be defined for each individual component. 
The Initialization Check normally checks that all parameters required for the component initialization have legal values. 
The Initialization Action is only performed if the Initialization Check was successful. 
This action normally creates all data structures required by the component and it performs other initialization actions as required. 
The Initialization Action can either fail or succeed.

The Initialization Procedure terminates in one single cycle with an outcome of either “Success” of “Failure”. 
Only the “Success” outcome is nominal and leads to the component making a transition to state INITIALIZED.

After successful initialization, the application provides to the component the information required to configure it and then sends a \texttt{Reset} command to it. 
The component responds by running its \textit{Reset Procedure}. 
This procedure is responsible for configuring the component and is defined in figure  \ref{fig:ResetPr}.
 
The \textit{Reset Procedure} is based on a \textit{Configuration Check} and a \textit{Configuration Action}. 
Both the check and the action are adaptation points which must be defined for each individual componet. 
The Configuration Check normally checks that all parameters required for the component configuration have legal values. 
The Configuration Action is only performed if the Configuration Check was successful. 
This action normally initializes the value of all data structures required by the component and it performs other configuration actions as required. 
The Configuration Action can either fail or succeed.

The Reset Procedure terminates in one single cycle with an outcome of either “Success” of “Failure”. 
Only the “Success” outcome is nominal and leads to the component making a transition to state CONFIGURED.

\begin{figure}[ht]
 \centering
 \includegraphics[scale=0.44,keepaspectratio=true]{InitializationPr.png}
 \caption{Initialization Procedure}
 \label{fig:InitializationPr}
\end{figure}

\begin{figure}[ht]
 \centering
 \includegraphics[scale=0.44,keepaspectratio=true]{ResetPr.png}
 \caption{Reset Procedure}
 \label{fig:ResetPr}
\end{figure}


State CONFIGURED is the normal operational state of a component. 
In this state, the component executes its \textit{Execution Procedure}. 
This procedure must be entirely defined at application level. 

A component can be reset at any time by sending it command \texttt{Reset}. 
Nominally, this results in the component executing again its configuration actions and re-entering its CONFIGURED state. 
However, if any of the component parameters are found to have non-nominal values or if any of the configuration actions fail, then the component makes a transition to state INITIALIZED. 
This is a non-nominal situation.

Thus, the distinction between initialization actions and configuration actions is that the former are actions that, nominally, are performed only once during the life of an application whereas the latter are actions which may be performed more than once.

Note that there is no distinction between the actions that are performed when a component is configured for the first time during application start-up and the actions that are performed when a component is reset at run-time. 
This is intentional because resetting a component should bring it to the same state in which it was when the application had completed its start-up.

All framework components implement the behaviour defined by the \textit{Base State Machine}. In general, the “meaningful” behaviour of a framework component is defined within the CONFIGURED state. 
This “meaningful” behaviour is defined either by implementing an \textit{Execution Procedure} or by embedding a state machine within the CONFIGURED state.

Components are shut down by sending them command \texttt{Shutdown}. 
This command results in the shutdown action being executed on the component. 
Note that components can only be shutdown from state CONFIGURED.
This is because the Shutdown operation models an orderly shutdown which should only be performed after an application has successfully completed its start-up. 

All components provided by the CORDET Framework are guaranteed to implement the behaviour of the \textit{Base State Machine}. 
Application developers will normally have to provide additional components implementing their own application-specific functionalities.
The CORDET Framework is designed on the assumptions that these components, too, will implement the behaviour of the \textit{Base State Machine}.

The tables at the end of this section list the adaptation points and the requirements applicable to the component start-up function.

\begin{crAp}{BAS}{Adaptation Points for Component Start-Up}
\end{crAp}

\begin{crReq}{BAS}{Requirements Applicable to Component Start-Up}
\end{crReq}

%---------------------------------------------------------------------------------
\subsection{Application-Level Start-Up and shutdown}\label{sec:AppStartUp}
\input{CrFwAppStartUp.tex}


\begin{crAp}{AST}{Adaptation Points for Application Start-Up}
\end{crAp}

\begin{crReq}{AST}{Requirements Applicable to Application Start-Up}
\end{crReq}

%===========================================================================
\section{Command and Report Concept}\label{sec:CmdAndRepConcept}
This section describes the command and report concept assumed by the CORDET Framework. 
Based on these concepts, the next section will define the requirements applicable to the management of commands and reports by the CORDET Framework.

This section considers commands and reports at the abstract level only (see section \ref{sec:DefCmdRepConcepts}). 
The commanding and reporting models described here are therefore applicable to any command or report, irrespective of the specific service to which they belong or of the specific activities which the command triggers or of the specific information which the report carries. 
Concrete commands and reports are defined by applications according to their needs. 
These concrete commands and reports are defined as specializations of the generic command and report concepts described in the present section. 



%--------------------------------------------------------------------------------
\subsection{Command Concept }\label{sec:CmdConcept}
\input{CrFwCmdConcept.tex}
 

%---------------------------------------------------------------------------------
\subsection{Report Concept }\label{sec:RepConcept}
\input{CrFwRepConcept.tex}


%===========================================================================
\clearpage
\section{Packet Interface}\label{sec:PcktInterface}

CORDET applications interact with each other by exchanging commands and reports. Within an application, commands and reports are encapsulated in components but, when they travel from one application to another (over some communication channel which is provided by some middleware external to the applications themselves), they take the form of \textit{packets} (see section \ref{sec:MwLayer}). A report or command packet is an ordered sequence of bytes that contains all the information required to reconstruct a report or command. 

Thus, the interface between two CORDET applications is packet-based. More precisely, an application needs an \textit{out-going interface} through which it can send to another application a packet representing a command or a report and it needs an \textit{incoming interface} through which it can receive from other applications packets representing commands or reports.  

The CORDET Framework assumes that a middleware is present which offers \textit{physical connections} through which two applications can send packets to each other. A physical connection then is a data channel provided by a middleware and capable of transporting packets from one application to another application. 

A CORDET system (namely a set of CORDET applications connected to each other by a middleware) builds a set of \textit{logical connections} on top of the physical connections offered by the middleware. A logical connection allows two applications A1 and A2 to exchange packets either directly through a physical connection linking A1 to A2 (in which case the logical connection coincides with a physical connection) or through a chain of other applications which are linked to each other and to A1 and A2 by physical connections. This is illustrated in figure \ref{fig:PhysicalAndLogicalConnections}. The figure shows a CORDET system consisting of four applications (yellow boxes in the figure). The applications are linked to each other by three physical connections (black lines in the figure). In this system, the following kinds of logical connections might, for instance, be defined:

\begin{enumerate}
\item A logical connection between applications A and B which is built upon physical connection C1;
\item A logical connection between applications B and D which is built upon physical connection C3;
\item A logical connection between applications A and C which is built upon physical connections C1 and C2 and application B acting as re-routing node.
\end{enumerate}

When a packet travels through an application en route to another application, it is said to be \textit{re-routed}. Packet re-routing is a function which is defined by the CORDET Framework and is therefore supported by default by CORDET Systems. In figure \ref{fig:PhysicalAndLogicalConnections} a packet travelling along a logical connection from application A to application C is re-routed by application B.

This section specifies the interfaces through which applications send packets to and receive them from the middleware and it specifies the re-routing logic which allows applications to exchange packets even in the absence of a direct physical connection linking them. 

\begin{figure}[ht]
 \centering
 \includegraphics[scale=0.45,keepaspectratio=true]{PhysicalAndLogicalConnections.png}
 \caption{Physical And Logical Connections}
 \label{fig:PhysicalAndLogicalConnections}
\end{figure} 

%---------------------------------------------------------------------------------
\subsection{Middleware Assumptions}\label{sec:MwAssumptions}
\input{CrFwMwAssumptions.tex} 

%---------------------------------------------------------------------------------
\subsection{Packet Interface Concept and Specification}\label{sec:PcktInterfaceConcept}

The packet interface concept for CORDET applications is illustrated in figure \ref{fig:PcktInterfaceConcept} using an information notation.

The management of the out-going packet interface is performed by \chgC{one or more OutStream components. An OutStream component encapsulates an out-going interface through which packets are sent to a set of related destinations. }

The management of the incoming packet interface is performed by an InStream component. \chgC{An InStream component encapsulates the incoming interface through which an application receives packets from a set of related packet sources. }

Packets which are received by an InStream in application A and which have application A as their destination are made available to the internal components of application A. Packets which are received by an InStream in application A and which have an application other than A as their destination are instead re-routed. This means that they are handed over to an OutStream for forwarding to another application (either their final destination or another intermediate application on the way to their final destination).

As an example, consider again the CORDET System of figure \ref{fig:PhysicalAndLogicalConnections} and consider first the case of a packet which is sent by application A to application B over connection C1. This packet is placed on connection C1 by an OutStream in application A and is received by an InStream in application B. Since the destination of the packet is application B itself, the InStream makes the packet available to the internal components of application B.

Consider next the case of a packet which is sent by application A to application C and which must therefore be re-routed by application B. This packet is initially placed on connection C1 by an OutStream in application A and is received by an InStream in application B. This InStream recognizes that the packet destination is not B and therefore re-routes it by directly handing it over to an OutStream which places it on connection C2. At the other end of this connection, the packet is received by an InStream in application C which recognizes that the packet has arrived at its final destination and therefore makes it available to the internal components of application C. 

\begin{figure}[ht]
 \centering
 \includegraphics[scale=0.45,keepaspectratio=true]{PcktInterfaceConcept.png}
 \caption{Packet Interface Concept}
 \label{fig:PcktInterfaceConcept}
\end{figure}

%---------------------------------------------------------------------------------
\subsubsection{The OutStream Component}\label{sec:OutStream}
\input{CrFwOutStream.tex}

The logic of the \textit{OutStream State Machine} together with the assumptions made in section \ref{sec:OutGoingConnections} about out-going middleware connections guarantee the following properties:

\begin{itemize}
\item[P1]{Packets are sent out in the order in which they are received.}
\item[P2]{No packet is ever lost by an OutStream.}
\item[P3]{There cannot be a permanent backlog of unsent packets.}
\item[P4]{An OutStream never deadlocks.}
\end{itemize}

Properties P1 and P2 are implicit to the OutStream logic. Property P1 is guaranteed because only the oldest packet from the Packet Queue is ever handed over to the middleware. Property P2 is guaranteed because a packet can only be lost if it is handed over to the middleware and the middleware fails to deliver. However, in this case, the packet remains enqueued and will be sent again.

Properties P3 and P4 are verified on the Promela model of the OutStream presented in appendix \ref{sec:VerModels}. 

\begin{crAp}{OST}{Adaptation Points for OutStream Component}
\end{crAp}

\begin{crReq}{OST}{Requirements Applicable to OutStream Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The InStream Component}\label{sec:InStream}
\input{CrFwInStream.tex}

\begin{crAp}{IST}{Adaptation Points for InStream Component}
\end{crAp}


\begin{crReq}{IST}{Requirements Applicable to InStream Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The OutStreamRegistry Component}\label{sec:OutStreamRegistry}
\input{CrFwOutStreamRegistry.tex}

\begin{crAp}{OSR}{Adaptation Points for OutStreamRegistry Component}
\end{crAp}

\begin{crReq}{OSR}{Requirements Applicable to OutStreamRegistry Component}
\end{crReq}



%===========================================================================
\section{Command And Report Management}\label{sec:CmdAndRepManagement}

This section specifies the requirements applicable to the management of service commands and service reports. The specification is based on the command and report concept described in section \ref{sec:CmdAndRepConcept}. 

The present section covers the management of abstract commands and reports. The requirements defined in this section are therefore applicable to any command or report, irrespective of the specific service to which they belong, or of the specific activities which a command triggers, or of the specific data which a report carries. Concrete commands and reports are defined in later parts of this document where the CORDET standard services are defined. These concrete commands and reports are defined as specializations of the generic command and report components defined in the present section. 

The management of out-going commands and out-going reports is specified in sub-section \ref{sec:ManagementOfOutGoingCmdAndRep}. The management of incoming commands and reports is specified in sub-section \ref{sec:ManagementOfIncomingCmdAndRep}. Throughout this section, the term “component” is used to designate a component whose behaviour extends the behaviour of the Base State Machine of section \ref{sec:BaseCmp}. 

%---------------------------------------------------------------------------------
\subsection{Management of Out-Going Commands and Reports}\label{sec:ManagementOfOutGoingCmdAndRep}
\input{CrFwManagementOfOutGoingCmdAndRep.tex} 

The following sub-sections specify each component type involved in the management of out-going commands and reports with the exception of the OutStream component which was specified in section \ref{sec:OutStream}. 

%---------------------------------------------------------------------------------
\subsubsection{The OutComponent Component}\label{sec:OutComponent}
\input{CrFwOutCmp.tex} 

The tables at the end of this section lists the adaptation points and requirements of the OutComponent component. The “Acknowledge Level Attribute” adaptation point is only meaningful for out-going commands. In the case of OutComponents representing out-going reports, this adaptation point is therefore ignored.

\begin{crAp}{OCM}{Adaptation Points for OutComponent Component}
\end{crAp}

\begin{crReq}{OCM}{Requirements Applicable to OutComponent Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The OutFactory Component}\label{sec:OutFactory}

When an application needs to send a command or a report to another application, it must first create an instance of an OutComponent to encapsulate the out-going command or report. The OutFactory component encapsulates the instance creation process.

The OutFactory component is a factory component in the sense of section \ref{sec:CmpInst}. As such it is subject to the general factory component requirements stated in that section. The present section defines the requirements which are specific to the OutFactory component.

Like all factory components, the OutFactory component offers a \texttt{Make} operation. The \texttt{Make} operation takes as arguments the type, sub-type and discriminant value of the out-going command or report. It is recalled that these three attributes fully determine the format of the command or report instance (see sections \ref{sec:CmdAttributes} and \ref{sec:RepAttributes}. They therefore provide sufficient information to let the OutFactory create an unconfigured instance of the command or report.

Depending on the allocation policy used internally in the OutFactory, the OutComponent component may be either in state CREATED, or in state INITIALIZED, or in state CONFIGURED. It is then the responsibility of the user application to initialize and/or configure the OutComponent.

The \texttt{Make} operation of the OutFactory sets the values of the following attributes of the newly created command or report:
\begin{itemize}
\item The service type, command or report sub-type, and discriminant are set according to the arguments of the Make operation.
\item The identifier attribute is set to a value representing the number of command or report instances which the factory has created since it was initialized.
\item The source attribute is set to the identifier of the host application.
\end{itemize}

Thus, a command or report component which is returned by the OutFactory has valid and correct values for the following attributes: service type, command or report sub-type,  discriminant,  identifier, and source. Other attributes must be set as part of the command or report configuration by the host application. Note, however, that the time stamp is set \chgC{at the time the OutComponent is serialized (see section \ref{sec:OutComponent})} and the sequence counter is set by the OutStream directly on the out-going packet at the time the packet is handed over to the middleware (see section \ref{sec:OutStream}).

\chgC{
The maximum number of OutComponents which a factory may generate is an adaptation point. The range of OutComponent kinds that an OutFactory can generate, namely the set of OutComponent service types, service sub-types and discriminants which the OutFactory recognizes and for which it can generate an OutComponent through its \texttt{make} operation is another adaptation point of the framework. The OutFactory must additionally support the adaptation points defined for a generic factory component (see section \ref{sec:CmpInst}). 
}

\begin{crAp}{OFT}{Adaptation Points for OutFactory Component}
\end{crAp}

\begin{crReq}{OFT}{Requirements Applicable to OutFactory Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The OutLoader Component}\label{sec:OutLoader}
\input{CrFwOutLoader.tex}

\begin{crAp}{OLD}{Adaptation Points for OutLoader Component}
\end{crAp}

\begin{crReq}{OLD}{Requirements Applicable to OutLoader Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The OutManager Component}\label{sec:OutManager}
\input{CrFwOutManager.tex}

\begin{crAp}{OMG}{Adaptation Points for OutManager Component}
\end{crAp}

\begin{crReq}{OMG}{Requirements Applicable to OutManager Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The OutRegistry Component}\label{sec:OutRegistry}
\input{CrFwOutRegistry.tex}

\begin{crAp}{ORG}{Adaptation Points for OutRegistry Component}
\end{crAp}

\begin{crReq}{ORG}{Requirements Applicable to OutRegistry Component}
\end{crReq}

%---------------------------------------------------------------------------------
\newpage
\subsection{Management of Incoming Commands and Reports}\label{sec:ManagementOfIncomingCmdAndRep}
\input{CrFwManagementOfIncomingCmdAndRep.tex}

The following subsections specify each component type involved in the processing of incoming commands or reports with the exception of the InStream component which was specified in section \ref{sec:InStream}. 

%---------------------------------------------------------------------------------
\subsubsection{The InFactory Component}\label{sec:InFactory}

When an application receives a packet representing a command or a report from another application, it must first create an instance of an InCommand or InReport to encapsulate the incoming command or report. The InFactory component encapsulates the instance creation process.

The InFactory component is a factory component in the sense of section \ref{sec:CmpInst}. As such it is subject to the general factory component requirements stated in that section. The present section defines the additional requirements specific to the InFactory component.

Like all factory components, the InFactory component offers a \texttt{Make} operation. The \texttt{Make} operation takes as arguments the type, sub-type and discriminant value of the incoming command or report. It is recalled that these three attributes fully determine the format of the command or report instance (see sections \ref{sec:CmdAttributes} and \ref{sec:RepAttributes}). They therefore provide sufficient information to let the InFactory create an unconfigured instance of the command or report.

Depending on the allocation policy used internally in the InFactory, the InCommand or InReport component may be either in state CREATED, or in state INITIALIZED, or in state CONFIGURED. It is then the responsibility of the user application to initialize and/or configure the InCommand or InReport.

A command or report component which is returned by the InFactory has valid values for the following attributes: service type, command or report sub-type, and discriminant. All other attributes must be set as part of the command configuration which is performed under the control of the InLoader (see next section).

\chgC{
The maximum number of InReporta and of InCommands which an InFactory may generate is an adaptation point. The range of InReport and InCommand kinds that an InFactory can generate, namely the set of InReport/InCommand service types, service sub-types and discriminants which the InFactory recognizes and for which it can generate an InReport/InCommand through its \texttt{make} operation is another adaptation point of the framework. The InFactory must additionally support the adaptation points defined for a generic factory component (see section \ref{sec:CmpInst}). 
}

\begin{crAp}{IFT}{Adaptation Points for InFactory Component}
\end{crAp}

\begin{crReq}{IFT}{Requirements Applicable to InFactory Component}
\end{crReq}


%---------------------------------------------------------------------------------
\subsubsection{The InLoader Component}\label{sec:InLoader}
\input{CrFwInLoader.tex}

\begin{crAp}{ILD}{Adaptation Points for InLoader Component}
\end{crAp}

\begin{crReq}{ILD}{Requirements Applicable to InLoader Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The InCommand Component}\label{sec:InCommand}
\input{CrFwInCommand.tex}

\begin{crAp}{ICM}{Adaptation Points for InCommand Component}
\end{crAp}

\begin{crReq}{ICM}{Requirements Applicable to InCommand Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The InReport Component}\label{sec:InReport}
\input{CrFwInReport.tex}

\begin{crAp}{IRP}{Adaptation Points for InReport Component}
\end{crAp}

\begin{crReq}{IRP}{Requirements Applicable to InReport Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The InManager Component}\label{sec:InManager}
\input{CrFwInManager.tex}

\begin{crAp}{IMG}{Adaptation Points for InManager Component}
\end{crAp}

\begin{crReq}{IMG}{Requirements Applicable to InManager Component}
\end{crReq}

%---------------------------------------------------------------------------------
\subsubsection{The InRegistry Component}\label{sec:InRegistry}
\input{CrFwInRegistry.tex}

\begin{crAp}{IRG}{Adaptation Points for InRegistry Component}
\end{crAp}

\begin{crReq}{IRG}{Requirements Applicable to InRegistry Component}
\end{crReq}


\appendix
%===========================================================================
\section{Verification Models}\label{sec:VerModels}
This section presents the models which have been used to formally verify some of the properties offered by the CORDET Framework. The verification models are written in Promela and the verification of the properties has been done using the Spin model checker.

%---------------------------------------------------------------------------------
\subsection{The OutStream Model}\label{sec:OutStreamModel}

In section \ref{sec:OutStream}, four properties are defined on the OutStream. Two of these properties – properties P3 and P4 – are verified on the Promela model listed below. Note that the model is based on blocking middleware which is periodically polled for its availability. From a verification point of view, this is the most general case for the following reasons:
\begin{itemize}
\item The case of a non-blocking middleware obviously represents a special case of a blocking middleware.
\item The polling approach is more general than a call-back approach because a call-back approach implies that, when the middleware makes a transition from NOT\_AVAIL to AVAIL, then, eventually, operation \texttt{ConnectionAvailable} is called upon the OutCmdStream. A polling approach implies the same thing but, in addition, it also implies that operation \texttt{ConnectionAvailable} may be called when no transition from NOT\_AVAIL to AVAIL has taken place.
\end{itemize}
Property P3 states that there never builds up a backlog of unsent packets in an OutStream. The verification of this property is based on a never claim. The never claim checks that the following LTL formula is always satisfied:

\lstset{belowskip=-14pt} % Vertical space after listing
\begin{lstlisting}
	#define r	(mwState==AVAIL)
	#define q	(outCmdStreamLock!=CMD_MNG)
	#define s	(outCmdStreamPQ==EMPTY)
	((<> [] q)  && (<> [] r)) -> ( (<> [] s) )
\end{lstlisting}

This formula can be expressed as follows: if the OutManagers stop making requests for fresh packet to be sent and if the middleware connection remains available, then the OutStream will eventually flush its packet queue. Note that this property only holds under conditions of weak fairness. 

Property P4 states that the OutStream never deadlocks. This property is verified because the Promela model below has no invalid end states.

The model verifies an additional property P5 which states that, at entry in state READY, the packet queue is always empty. This property is verified through an assertion.

\lstset{belowskip=-1pt}	% Vertical space after listing
\lstinputlisting{./VerificationModel/PollingOutCmdStream.pml}



\end{document}  