ReqN|ReqTitle|ReqText|Status|Justification||||
5.3.1a|General|Each service type shall be uniquely identified by exactly one service type name.|C1/C2|The service type names and identifiers of pre-defined services are taken from the PUS and the service types names and identifiers of other services are set by the application developers at adaptation point ICM-18 for incoming commands and OCM-7 for out-going reports.||||
b||Each service type shall be uniquely identified by exactly one service type identifier that is an unsigned integer greater than or equal to 1, and less than or equal to 255.|C1/C2|See justification of first requirement in this clause||||
c||Each standard service type shall have a service type identifier less than or equal to 127.|C1/C2|See justification of first requirement in this clause||||
d||Each mission specific service type shall be associated with a service type identifier greater than or equal to 128.|C1/C2|See justification of first requirement in this clause||||
5.3.2a|Subservice Type|Each service type shall define at least one subservice type.|C1/C2|For pre-defined services, the PUS is followed and at least one sub-service is defined. For other services, adaptation points ICM-19 for incoming commands and OCM-8 for out-going reports imply definition of a sub-service for each service.||||
b||Each subservice type shall be defined by exactly one service type.|C1/C2|See justification of first requirement in this clause||||
c||Each subservice type shall be uniquely identified by exactly one subservice type name.|C1/C2|See justification of first requirement in this clause||||
d||For each subservice type, whether the realization of that subservice type is implicitly required for each realization of the service type or required by tailoring shall be declared when specifying that subservice type.|C1|For pre-defined services, dependencies between sub-services are identified and formulated as use constraint requirements.||||
e||For each subservice type, whether multiple realizations of that subservice type are allowed within a single service shall be declared when specifying that subservice type.|NA|This requirement does not concern the implementation of the services and is therefore outside the scope of the PUS Extension of the CORDET Framework (TBC)||||
f||For each subservice type, the observables shall be declared when specifying that subservice type.|C1|A list of observables is provided for each pre-defined service offered by the PUS Extension of the CORDET Framework||||
5.3.3.1a|Message Type|Each message type shall be uniquely identified by exactly one message type name.|C1|The CORDET Framework implements a message as a command or report exchanged between applications and identifies the type of a message through the triplet [type, sub-type, discriminant]. See section 4 of CORDET Framework Definition Document.||||
b||Each message type shall be uniquely identified by exactly one message type identifier.|C1|See justification of first requirement in this clause||||
c||Each message type identifier shall be composed of: \newline 1. the service type identifier of the service type that contains that message type; \newline 2. a message subtype identifier that uniquely identifies that message type within that service type.|C1|See justification of first requirement in this clause||||
d||Each message subtype identifier shall be an unsigned integer greater than or equal to 1, and less than or equal to 255.|C1/C2|For pre-defined services, the command and report types are taken over from the PUS. For other services, they are under the control of the application developer through adaptation points ICM-18, ICM-19, OCM-7 and OCM-8.||||
e||Each standard message type identifier shall have a message subtype identifier less than or equal to 127.|C1/C2|See justification of requirement e in this clause.||||
f||Each mission specific message type that belongs to a standard service type shall have a service subtype identifier greater than or equal to 128.|C1/C2|See justification of requirement e in this clause.||||
g||Each message type shall either be: \newline 1. a request type, or \newline 2. a report type.|C1|See justification of first requirement in this clause||||
5.3.3.2a|Request Type|Each request type shall define one or more instruction types.|C1/C2|For pre-defined services, the PUS definition is followed. For application-dependent services, the user is responsible for providing the information requested in this requirement. ||||
b||Each instruction type shall be defined for exactly one request type.|C1/C2|See justification of first requirement in this clause||||
c||Each instruction type shall be uniquely identified by exactly one instruction type name.|C1/C2|See justification of first requirement in this clause||||
d||For each request type and for each instruction type of that request type, whether that request type provides a single instruction slot or multiple instruction slots for that instruction type shall be declared when specifying that request type.|C2|For requests which may include multiple instructions, the PUS Extension does not impose any upper boundary on the number of instructions in a command. Any such upper boundary must be imposed by the user (e.g. in the command database).||||
e||For each request type that contains several instruction types, the allowed combinations of instruction types that can be used in a request of that request type shall be declared when specifying that request type.|C1|For all services pre-defined by the PUS Extension, when a request instance may contain multiple instructions, then those instructions are all of the same type (TBC).||||
f||For each instruction type, the instruction arguments used by that instruction type, their definition and their ordering within the instruction type shall be declared when specifying that instruction type.|C1/C2|The complete layout of a request must be defined as part of the definition of a command (see adaptation points OCM-12 and ICM-21)||||
g||For each request type that provides multiple instruction slots, if that request type constrains the scope of the instructions that can be issued within a request of that type, the argument or set of arguments of the related instruction types that define that scope shall be grouped together in the definition of the request type.|TBC|This requirement is not understood. It presumably refers to a situation where a multi-instruction request carries parameters which apply to all instructions in the request. The requirement states that those parameters must be grouped together. If this interpretation is correct, then the services pre-defined by the PUS Extension are compliant.||||
h||For each request type, the definition of the request arguments provided by that request type, their definition and their ordering within the request type shall be declared when specifying that request type.|C1/C2|See justification requirement f in this clause.||||
5.3.3.3a|Report Type|Each report type shall either be: \newline 1. a data report type, \newline 2. a verification report type, or \newline 3. an event report type.|C1/C2|For pre-defined services, the report types are taken over from the PUS. For other services, the report type is under the control of the application developer through adaptation points OCM-*.||||
b||Each report type shall define exactly one notification type.|C1/C2|In the CORDET Framework, notifications are implicitly defined within reports||||
c||Each notification type shall be defined for exactly one report type.|C1/C2|See justification of first requirement in this clause||||
d||Each notification type shall be uniquely identified by exactly one notification type name.|C1/C2|See justification of first requirement in this clause||||
e||For each report type and for each notification type of that report type, whether that report type provides a single notification slot or multiple notification slots for that notification type shall be declared when specifying that report type.|C1/C2|See justification of first requirement in this clause||||
5.3.4a|Capability Type|Each subservice type shall define at least one capability type.|C1/C2|The capability types are defined implicitly when a service is defined. For the pre-defined services, the PUS Extension follows the PUS.||||
b||For each capability type defined by a subservice type, the applicability constraints of that capability type shall be declared when specifying that subservice type.|C2|The CORDET Framework does not enforce any compatibility constraints. These must be enforced by users during the instantiation process||||
5.3.5.1a|Transaction Type|Each transaction type shall be defined by exactly one capability type.|NA|This requirement does not concern the implementation of the services and it therefore has no impact on the PUS Extension of the CORDET Framework||||
b||Each transaction type shall either be: \newline 1. a request related transaction type, \newline 2. an autonomous data reporting transaction type, or \newline 3. an event reporting transaction type.|NA|See justification of previous requirement.||||
5.3.5.2.1a|Request related transaction type|Each request related transaction type shall involve exactly one request type.|C1|The CORDET Framework only defines individual commands and report. The PUS Extension implicitly defines transactions when it specifies links between a command and the reports it triggers or when it specified the conditions under which data or event reports are generated. Compliance with the requirement is guaranteed for the services pre-defined by the PUS Extension which follow the PUS. ||||
b||Each request type shall be involved in exactly one request related transaction type.|C1|See justification of previous requirement.||||
5.3.5.2.2a|Response Type|Each request type shall be linked to at most one data report type.|C1|See justification of first requirement of clause 5.3.5.2.1||||
b||For each instruction type that is linked to a notification type, whether a realization of that instruction type can cause the generation of multiple notifications shall be declared when specifying that instruction type.|C1|See justification of first requirement of clause 5.3.5.2.1||||
5.3.5.2.3a|Execution verification profile|For each request type, the pre-conditions to verify prior to starting the execution of each request of that type shall be declared when specifying that request type.|C1|The condition to start execution of a command are verified in the command's Start Action (adaptation points ICM-8)||||
b||For each instruction type, the pre-conditions to verify prior to starting the execution of each instruction of that type shall be declared when specifying that instruction type.|C1|The CORDET Framework does not directly implement the concept of instructions. Instructions are therefore implicitly embedded within commands. Verification of their execution pre-conditions can be done either as part of a command's Start Action (adaptation point ICM-8) or as part of the the command's Progress Action (adaptation point ICM-9). For the commands pre-defined by the PUS Extension, the first option has been selected and the pre-conditions for execution of a command are verified as part of that commandâ€™s Start Action.||||
c||For each request type that provides a multiple instruction slots capability, whether the subservice verifies the suitability of all instructions contained within each request of that type before authorizing the start of execution of that request shall be declared when specifying that request type.|C1/C2|For the services PUS Extension, the rules stated in the PUS are followed. For other services, users choose between these two options when they Implement the Start Action of a command.||||
d||For each instruction type, the conditions to verify during the execution of each instruction of that type shall be declared when specifying that instruction type.|C1/C2|See justification of previous two requirements||||
e||For each instruction type, the post-conditions to verify at the end of the execution of each instruction of that type shall be declared when specifying that instruction type.|C1|The post-conditions of an instruction can be verified either in the Progress Action (adaptation point ICM-9) or in the Termination Action (adaptation point ICM-10). For commands pre-defined by the PUS Extension, the second option has been chosen.||||
f||For each request type, the post-conditions to verify at the end of the execution of each request of that type shall be declared when specifying that request type.|C1|The post-conditions of a request must be verified in the Termination Action of a command (adaptation point ICM-10). ||||
g||For each request type, the execution verification profile used to report the start, progress and completion of execution of each request of that type shall be declared when specifying that request type.|C1|The execution verification profile of a request is specified when the Start Action, Progress Action and Termination Action of a command are specified (adaptation points ICM-8, 9 and 10). Adaptation point ICM12 to 17 can be used to specify how the notifications of the verification outcomes should be handled.||||
h||Each progress of execution notification shall provide the means to uniquely identify the instruction that progress of execution is notified.|C1|The progress of execution notifications are generated through calls to the Operation to Report Progress Success for InCommand and the Operation to Report Progress Failed for InCommand (adaptation points ICM-14 and 15). These operations take the command identifier and the execution step identifier as arguments. The latter can be used to identify the instruction which failed or succeeded.||||
I||For each instruction type, the functionality that the subservice performs when executing an instruction of that type shall be declared when specifying that instruction type.|C1|The functionality executed when a command is executed is defined by the Progress Action of the command which holds the instruction (adaptation points ICM-9). This action therefore implements both the request-level and instruction level actions.||||
j||For each request type, the request-specific functionality that the subservice performs when executing a request of that type shall be declared when specifying that request type.|C1|See previous requirement||||
5.3.5.3a|Autonomous data reporting transaction type|Each autonomous data reporting transaction type shall involve exactly one data report type.|C1|The CORDET Framework does not enforce this constraint. For the services in the PUS Extension, the rules of the PUS are followed and the constraint is therefore satisfied. ||||
b||Each data report type shall be involved in at most one autonomous data reporting transaction type.|C1|See justification of first requirement in this clause||||
5.3.5.4a|Event reporting transaction type|Each event reporting transaction type shall involve exactly one event report type.|C1|The CORDET Framework does not enforce this constraint. For the services in the PUS Extension, the rules of the PUS are followed and the constraint is therefore satisfied. ||||
b||Each event report type shall be involved in exactly one event reporting transaction type.|C1|See justification of first requirement in this clause||||
5.3.6|Tailoring the generic service type abstraction level|Tailoring the generic service type abstraction level shall consist of:  \newline 1. adding mission-specific service types; \newline 2. adding mission-specific subservice types; \newline 3. adding mission-specific capability types; \newline 4. adding mission-specific message types.|C2|The CORDET Framework allows new service types and sub-types to be added through adaptation points OCM-* and ICM-*. For each new service, mission-specific capabilities and messages can be associated. Capability and message types are defined implicitly through the definition of the service types and sub-types.||||
5.4.2.1a|Application process|Each application process shall either be: \newline 1. an on-board application process, or \newline 2. a ground application process.|C1|The way PUS-style application processes are implemented in the CORDET Framework is discussed in section 3.5 of the CORDET User Manual||||
b||Each application process that hosts at least one subservice provider shall be identified by an application process identifier that is unique across the system that hosts that subservice provider.|C2|Applications can customize the factory components which create the packets representing commands and reports (adaptation points FAC-1) such that they fill in the header information in the packets in accordance with their allocation of APIDs.||||
c||Each application process identifier shall be an unsigned integer that is less than or equal to 2046.|C2|See justification of previous requirement.||||
d||Each application process that hosts at least one subservice user shall be identified by an application process user identifier that is unique within the context of the overall space system.|C1|The application process user identifier of a service user is the source of commands issued by that service user and the destination of reports received by that service user. This can be mapped to the concept of command source and report destination (see section 4 of the CORDET Framework Definition Document). ||||
e||Each application process user identifier shall be an unsigned integer that is greater than or equal to 0, and less than or equal to 65535.|C1|See justification of previous requirement.||||
f||For each report that it generates, each on-board application process shall time tag that report using the on-board reference time.|C1|The time-stamp of out-going components is set by the Send Packet Procedure of the OutComponent of the CORDET Framework (see section 6.1.1 of the CORDET Framework Definition Document).||||
g||For each application process, whether that application process time tags the reports before collecting the values of the constituting parameters or after shall be declared when specifying that application process.|C1|In the CORDET Framework, the time-stamp of a report represents the time when an application makes a request to issue that report (this is after the report data have been collected). See section 4.2.1 of the CORDET Framework Definition Document.||||
h||For each application process, whether that application process provides the capability to report the status of the on-board time reference used when time tagging reports shall be declared when specifying that application process.|NA|The CORDET Framework defines an interface for acquiring the current time (see adaptation point C2-TIM-1 in [CR-UM]) but it does not include an interface for acquiring the status of the on-board time reference. This capability, if required, must be provided entirely at application level.||||
I||For each application process, whether that application process provides the capability to count the type of generated messages per destination and report the corresponding message type counter shall be declared when specifying that application process.|C1|The OutStream components maintain counters of out-going commands and reports sent to their destination (there is one OutStream for each destination). See section 5.2.1 of the CORDET Framework Definition Document. The framework however does not, by default, provide the capability to count the number of messages of a given type sent to a given destination.||||
j||Each application process that provides the capability to count the type of generated messages per destination and report the corresponding message type counter shall maintain, per destination, a counter for each message type that it generates.|C1|See justification of previous requirement.||||
5.4.3.2a|On-board parameter|Each on-board parameter shall be identified by exactly one on-board parameter identifier that is unique across the entire spacecraft.|C2|The PUS Extension of the CORDET Framework maps on-board parameters to the Data Items in the Data Pool Component. The application developer is responsible for defining the Data Items (see adaptation point DP-7) and this includes the allocation of their identifiers.||||
b||The set of on-board parameter minimum sampling intervals used to access the on-board parameters shall be declared when specifying the spacecraft architecture.|C2|The PUS Extension of the CORDET Framework does not enforce a minimum sampling time. This mus be enforced by the application. Note that the definition of service 3 includes the definition of a minimum collection period for housekeeping reports (HK\_COLLECT\_PER)||||
c||Each on-board parameter shall be associated to exactly one on-board parameter minimum sampling interval.|C2|See justification of requirement b in this clause||||
d||All on-board parameters accessed by an application process shall be associated to the same on-board parameter minimum sampling interval.|C2|See justification of requirement b in this clause||||
5.4.3.3.1a|On-board memory|Each on-board memory shall be identified by exactly one on-board memory identifier.|C2|The on-board memory identifiers and the characteristics of the on-board memories are defined as part of the instantiation of service 6. See adaptation points TBD.||||
b||At any time, each on-board memory identifier shall uniquely identify exactly one on-board memory that is unique across the entire spacecraft.|C2|See justification of first requirement in this clause||||
c||For each on-board memory, the following characteristics of that memory shall be declared when specifying that memory: \newline 1. the memory access alignment constraint; \newline 2. the memory size, in bytes; \newline 3. the allowed operations; \newline 4. the addressing scheme.|C2|See justification of first requirement in this clause||||
d||When declaring the characteristics of an on-board memory, the allowed operations shall be one of the following: \newline 1. 'read only'; \newline 2. 'read and write'; \newline 3. 'write only'.|C2|See justification of first requirement in this clause||||
e||For each on-board memory, whether scrubbing that memory is supported shall be declared when specifying that memory.|C2|See justification of first requirement in this clause||||
f||For each on-board memory, whether write protecting that memory is supported shall be declared when specifying that memory.|C2|See justification of first requirement in this clause||||
5.4.3.3.2a|Addressing Scheme|For each on-board memory, whether an absolute addressing scheme for that memory is exposed in the space to ground interface shall be declared when specifying that memory.|C2|See justification of first requirement in the previous clause||||
b||Absolute addressing implies that the memory addresses and related offsets shall be expressed in bytes.|C2|See justification of first requirement in the previous clause||||
c||For each on-board memory, whether a base plus offset addressing scheme for that memory is exposed in the space to ground interface shall be declared when specifying that memory.|C2|See justification of first requirement in the previous clause||||
d||Base plus offset addressing implies that the base references when expressed as an absolute address and related offsets shall be expressed in bytes.|C2|See justification of first requirement in the previous clause||||
5.4.3.4a|Virtual channel|The list of virtual channels defined for downlinking reports and their characteristics shall be declared when specifying the space to ground interface.|NA|This requirement does not concern the implementation of the services and is therefore outside the scope of the PUS Extension of the CORDET Framework||||
b||For each virtual channel defined for downlinking reports, the virtual channel identifier used to refer to that virtual channel shall be declared when specifying that virtual channel.|NA|This requirement does not concern the implementation of the services and is therefore outside the scope of the PUS Extension of the CORDET Framework||||
5.4.4|Checksum algorithm|For each checksum algorithm used on-board, the list of subservice providers that use that checksum algorithm shall be declared when specifying the spacecraft architecture.|C2|In the PUS Extension of the CORDET Framework, the checksumming of commands and reports is not explicitly modelled and it must be provided by the application in order to compute the CRC field of commands and reports.||||
5.4.5a|On-board file system|Each on-board file system shall be identified by exactly one on-board file system identifier that is unique across the entire spacecraft.|C2|The on-board file system and their characteristics are defined as part of the instantiation of service 23. See adaptation points TBD.||||
b||Each object in an on-board file system shall be uniquely identified by an object path that is the combination of a repository path and an object name.|C2|See justification of first requirement in this clause||||
c||For each on-board file system, whether that file system supports files with unbounded size shall be declared when specifying that file system.|C2|See justification of first requirement in this clause||||
v||The set of file attributes supported by each on-board file system shall be declared when specifying that file system.|C2|See justification of first requirement in this clause||||
e||For each on-board file system, whether that file system provides the capability to lock files shall be declared when specifying file system.|C2|See justification of first requirement in this clause||||
f||An on-board file system shall not be accessed by more than one file management service.|C2|See justification of first requirement in this clause||||
5.4.6a|Service|Each service shall be of exactly one service type.|C1|To each CORDET Service, one single type attribute is assigned (see section 4.1.1 of the CORDET Framework Definition Document)||||
b||For each subservice type whose realization is implicitly required, each service of the related service type shall provide at least one subservice of that subservice type.|C2|The PUS Extension of the CORDET Framework does not enforce this requirement. It is up to the user to instantiate services which are implicitly required.||||
c||For each subservice type whose realization is required by tailoring and for each service of the service type that defines that subservice type, whether the realization of that subservice type is required for that service shall be declared when specifying that service.|C2|See justification of requirement b in this clause||||
d||For each subservice type that allows multiple realizations within a single service, each realization of that subservice type shall be declared when specifying that service.|C2|See justification of requirement b in this clause||||
e||The service topology of the overall space system shall be declared when specifying the space system architecture.|C1|The service topology of a CORDET System is defined by several adaptation points and application developers are required to fill in all framework adaptation points (or accept their default implementation) as part of the application instantiation process||||
5.4.7.1a|Subservice|Each subservice shall be of exactly one subservice type.|NA|This and the next requirement are definitions rather than requirement. ||||
b||Each subservice shall belong to exactly one service.|NA|See justification of first requirement in this clause||||
5.4.7.2.1a|Subservice Entity|Each subservice entity shall belong to exactly one subservice.|NA|This and the next two requirements are definitions rather than requirement. ||||
b||Each subservice entity shall be hosted by exactly one application process.|NA|See justification of first requirement in the previous clause||||
c||Each subservice entity shall be either a subservice user or a subservice provider.|NA|See justification of first requirement in the previous clause||||
5.4.7.2.2a|Subservice Provider|Each subservice shall provide exactly one subservice provider.|NA|This requirement is a definition rather than a requirement||||
5.4.7.2.3a|Subservice User|Each subservice shall provide at least one subservice user.|NA|This requirement is a definition rather than a requirement||||
5.4.8a|Capability|Each subservice shall provide at least one subservice capability.|NA|This requirement is a definition rather than a requirement||||
5.4.8b||For each subservice and for each capability type defined by the corresponding subservice type, the inclusion of the related capability in that subservice shall comply with the applicability constraints of that capability type.|TBD|This requirement is not understood||||
5.4.9a|Failed progress of execution|For each request type for which a failed progress of execution can be reported, whether the corresponding failed progress of execution notifications are reported within failed progress of execution verification reports or as part of the completion of execution verification report for the related requests shall be declared when specifying the request type related subservice.|C1|The CORDET Framework supports both options but the option whereby the failed progress of execution is reported through a Failed Progress of Execution Notification is the most natural and it is the one which is selected by default in the PUS Extension.||||
5.4.10a|Transactions|Each subservice shall provide the means to manage all transactions that it initiates according to the mission operational requirements.|C1/C2|The CORDET Framework provides the means to manage incoming and out-going reports and commands. The PUS Extension implements the transaction rules mandated by the PUS.||||
b||Each transaction shall be initiated and maintained by exactly one subservice.|C1|See justification of previous requirement.||||
5.4.11.1a|Message|Each message shall be of a single message type.|C1| message is either a report or a request and its type is defined by the pair [service type, service sub-type]. The CORDET Framework directly supports the concepts of service types and sub-types and assigned one single type/sub-type pair to each message.||||
5.4.11.2.1a|Request|Each request shall be generated by exactly one subservice user.|C1|The CORDET Framework allows a command to have one single source.||||
b||Each request shall be addressed to exactly one subservice provider.|C1|The CORDET Framework allows a command to have only one single destination.||||
c||Each request shall be uniquely identified by a request identifier that is the combination of: \newline 1. a source identifier that corresponds to the application process user identifier of the application process that hosts the subservice user that generates that request; \newline 2. a destination identifier that corresponds to the combination of the application process identifier of the application process that hosts the subservice provider that is responsible for executing that request and the system identifier of the system that hosts that application process; \newline 3. a sequence count or request name that is produced by the application process that hosts the subservice user.|C1|CORDET Commands carry dentifiers of both their source and destination and a source sequence counter (see section 4.1 of the CORDET Framework Definition Document)||||
d||Each request shall be of exactly one request type.|C1|The type of a request is given by the pair [service type, service sub-type]. The CORDET Framework directly supports both the concept of service type and of service sub-type.||||
e||Each request whose request type provides a single instruction slot shall contain exactly one instruction that is of an instruction type defined for that request type.|C1|The PUS Extension defines request and instruction types in accordance with the PUS||||
f||Each request whose request type provides multiple instruction slots shall contain an ordered list of one or more instructions, each one being of an instruction type defined for that request type.|C1|The PUS Extension defines request and instruction types in accordance with the PUS||||
5.4.11.2.2a|Acknowledgement|Each request shall contain: \newline 1. a flag indicating whether the reporting of the successful acceptance of that request by the destination application process is requested; \newline 2. a flag indicating whether the reporting of the successful start of execution of that request by the destination application process is requested; \newline 3. a flag indicating whether the reporting of the successful progresses of execution of that request by the destination application process is requested; \newline 4. a flag indicating whether the reporting of the successful completion of execution of that request by the destination application process is requested.|C1|CORDET commands carry four acknowledgement flags which determined which of the four stages of their life-cycle (acceptance, start, progress, and termination) are acknowledged (see section 4.1 of the CORDET Framework Definition Document)||||
5.4.11.2.3a|Request execution verification|For each request that it receives, the subservice provider in charge of the execution of that request shall, in sequence: \newline 1. if the pre-conditions for the execution of that request are not fulfilled: \newline (a) notify the execution reporting subservice of its parent application process of the failed start of execution; \newline (b) stop processing that request; \newline 2. if the pre-conditions for the execution of that request are fulfilled, \newline notify the execution reporting subservice of its parent application process of the successful start of execution; \newline 3. for each step, if any: \newline (a) verify the execution conditions of that step, if any; \newline (b) if the execution conditions of that step are not fulfilled, notify the execution reporting subservice of its parent application process of the failed progress of execution of that step; \newline (c) if the step's execution conditions are fulfilled, notify the execution reporting subservice of its parent application process of the successful progress of execution of that step; \newline at the end of the execution of that request: newline (a) verify the post-conditions of execution, if any; \newline (b) if any step execution has failed or if the post-conditions of execution are not fulfilled, notify the execution reporting subservice of its parent application process of the failed completion of execution and stop processing that request; \newline (c) if the post-conditions of execution are fulfilled, notify the execution reporting subservice of its parent application process of the successful completion of execution;|C1|The life-cycle of a CORDET command in a service provider is defined in section 4.1 of the CORDET Framework Definition Document. As requested by this requirement, start, progress and completion of execution of a command are checked and notification may be sent out in response to these checks (see adaptation points ICM-12 to 17). However, failure of a progress step leads to termination of execution of the command. In such a case (failure of a progress step), the originator of the request is notified with one single failure report indicating the failure of the progress and, by implication, also the failure of the command completion. \newline This requirement only concerns reporting of verification outcomes for \underline{commands}. The PUS is silent about the conditions under which the outcome of instruction-level verifications should be reported. In this respect, the PUS Framework takes the  approach that, for instructions, only execution failures are reported and that they are reported unconditionally. ||||
5.4.11.3.1a|Report|Each report shall be generated by exactly one subservice provider.|C1|In the CORDET Framework, both reports and commands have one single source||||
b||Each report shall be addressed to exactly one subservice user.|C1|In the CORDET Framework, both reports and commands have one single destination||||
c||Each report shall be uniquely identified by a report identifier that is the combination of: \newline 1. a source identifier that is the application process identifier of the application process that hosts the subservice provider that generates that report; \newline 2. a destination identifier that corresponds to the application process user identifier of the application process that hosts the subservice user that is responsible for processing that report; \newline 3. a source sequence count that is produced by the application process that hosts the subservice provider.|C1|CORDET reports carry identifiers of both their source and destination and a source sequence counter (see section 4.2 of the CORDET Framework Definition Document)||||
d||Each report shall be of exactly one report type.|C1|The type of a CORDET report is given by the pair [type, sub-type].||||
e||Each report whose report type provides a single notification slot shall contain exactly one notification that is of a notification type defined for that report type.|C1|The PUS Extension defines report and notification types in accordance with the PUS||||
f||Each report whose report type provides multiple notification slots shall contain an ordered list of one or more notifications, where: \newline 1. all notifications in the list are of the same notification type, and \newline 2. that notification type is one of those defined for that report type.|C1|The PUS Extension defines report and notification types in accordance with the PUS||||
5.4.11.3.2a|Response|The destination of any response shall be the source of the corresponding request.|C1/C2|For pre-defined services, the PUS is followed. For application-specific services, this requirement must be enforced by application developers when they close adaptation point OCM-9.||||
||If a request implies the generation of a response that exceeds the length that can be carried in a telemetry packet of the maximum packet size of the CCSDS space packet protocol, that request shall be rejected.|C1/C2|For pre-defined services, the PUS is followed. For application-specific services, this requirement must be enforced by application developers when they define the Start Action for commands (see adaptation point ICM-12).||||
5.4.11.3.3a|Data Report|For each data report that can be generated in an autonomous data reporting transaction, the destination of the data report in that case shall be declared when specifying the related subservice.|C1/C2|For pre-defined services, the PUS is followed. For application-specific services, this requirement must be enforced by application developers when they close adaptation point OCM-9.||||
5.4.12a|Building the space system architecture|Deploying the service topology of an overall space system should consist of: \newline 1. specifying new implementations of PUS services by instantiating the service types and related components; \newline 2. assessing the adequacy of reusing existing service implementations: (a) ensuring their compliance to the PUS standard services; \newline (b) verifying their compliance to the overall system constraints.|NA|This requirement does not concern the implementation of the services and is therefore outside the scope of the PUS Extension of the CORDET Framework||||
6.1.2.1a|Request Verification|Each request verification service shall contain at least one of the following: \newline 1. one or more routing and reporting subservices, \newline 2. one or more acceptance and reporting subservices, \newline 3. one or more execution reporting subservices.|C1|The PUS Extension of the CORDET Framework provides adaptation points which allow an application to deploy: \newline (a) one routing and reporting subservice (this is part of the InLoader component which, in the CORDET Framework, is responsible for routing incoming packets, see adaptation points ILD-9, 11 and 12 in [CR-SP] ); \newline (b) one acceptance and reporting sub-service (this is part of the InLoader Load Command/Report Procedure which, in the CORDET Framework is responsible for the acceptance of incoming packets, see adaptation points ILD-14 and 15); and (c) one execution reporting sub-service for each command type (since, in the CORDET Framework, execution checks and reporting of their outcomes are done in the InCommand components which encapsulate incoming commands, see adaptation points ICM-12 to 17). The PUS Extension closes these adaptation points to provide an implementation which conforms to the requirements of service 1 in the PUS.||||
6.1.2.2.1a|Destination of verification reports|For each verification report that it generates, the application process shall address that report to the application process that hosts the subservice user that has generated the corresponding request.|C1|See close-out of adaptation point P-S1-10||||
6.1.2.2.2a|Application process that routes requests|Each application process that is involved in routing requests shall host exactly one routing and reporting subservice.|C1|See justification of clause 6.1.2.1a||||
6.1.2.2.3a|Application process that executes requests|Each application process that hosts one or more subservices that execute requests shall host: \newline 1. exactly one acceptance and reporting subservice; \newline 2. at most one execution reporting subservice.|C1|See justification of clause 6.1.2.1a. ||||
6.1.3.1.1a|Application Process|The list of application processes that the routing and reporting subservice addresses shall be declared when specifying the spacecraft architecture.|C2|This list is implicitly declared when, during the framework instantiation process, the adaptation point ILD-11 of the CORDET Framework is closed.||||
6.1.3.2a|Routing verification of a request|The routing and reporting subservice shall provide the capability to perform routing verification for the requests that it receives.|C1|In the CORDET Framework, routing of incoming packets is done by the InLoader component (see [CR-SP]). This component also verifies the validity of the command destination and routing information.||||
b||The list of routing verification checks that the routing and reporting subservice performs shall be declared when specifying that subservice.|C1|In the CORDET Framework, routing of incoming packets is done by the InLoader component (see [CR-SP]) which performs one single routing check to verify the validity of an incoming command or report. This check is implemented by closing adaptation point ILD-11.||||
c||For each request that it receives, the routing and reporting subservice shall: \newline 1. perform the routing verification checks on that request; \newline 2. determine, based on the output of those checks, whether the routing verification of that request has succeeded or failed.|C1|In the CORDET Framework, routing verification is performed by the InLoader. The routing check is implemented by closing adaptation point ILD-11 and the reporting of a routing failure is implemented by closing adaptation point ILD-12. The PUS Extension offers a component which closes adaptation point ILD-12 by generating a (1,10) report.||||
6.1.3.3a|Reporting Failed Routing|The routing and reporting subservice shall provide the capability to report the failed routing of requests.|C1|This capability is provided by the VerFailedRoutingRep component of the PUS Extension of the CORDET Framework||||
||Each failed routing verification report shall contain exactly one failed routing notification.|C1|See definition of VerFailedRoutingRep component of the PUS Extension of the CORDET Framework.||||
||Each failed routing notification shall contain: \newline 1. the identifier of the request that failed the routing verification; \newline 2. the failure notice made of: \newline (a) a failure code; \newline auxiliary data, if any, used to explain the reason for the failed routing.|C1|The specification of the (1,10) report provided by the PUS Extension follows the PUS. The auxiliary information is specified in the Packet Rerouting Failure Procedure.||||
||The list of failure codes defined for failed routing notifications shall be declared when specifying the routing and reporting subservice.|C1|The list of failure codes and their auxiliary data for service 1 reports is specified in appendix B of the PUS Specification Document||||
||For each failure code defined for failed routing notifications, the associated auxiliary data shall be declared when specifying the routing and reporting subservice.||See previous requirement||||
||For each request that fails its routing verification, the routing and reporting subservice shall: \newline 1. generate a single failed routing notification and associated report for that request; \newline 2. discard that request.|C1|See definition of Packet Rerouting Failure Procedure||||
6.1.4.1a|Acceptance verification of a request|The acceptance and reporting subservice shall provide the capability to perform acceptance verification for a request that it receives.|C1|In the CORDET Framework, the acceptance verification is performed by the InLoader Load Command/Report Procedure. Incoming commands are encapsulated in components of type InCommand. Each such component offers a Configuration Check (see adaptation point ICM-3) where the acceptance verification check is implemented. For the commands provided by the PUS Extension of the CORDET Framework, the verification check is specified at adaptation point P-PCR-21. ||||
b||The list of acceptance verification checks that the acceptance and reporting subservice performs during the acceptance verification of a request shall be declared when specifying that subservice.|C2|For all commands supported by the PUS Extension of the CORDET Framework, the InLoader Load Command/Report procedure which performs two acceptance checks: (a) check of the legality of the command type, and (b) check of available resources for the command in the host applications. The PUS Extension adds two more acceptance checks (see close-out of adaptation point ILD-13): (c) check of the command checksum and (d) check of the command length.||||
c||For each request that it receives, the acceptance and reporting subservice shall: \newline 1. perform the acceptance verification checks on that request; \newline 2. determine, based on the output of those checks, whether the acceptance verification of that request has succeeded or failed.|C1|In the CORDET Framework, the acceptance check for an incoming command is split into two parts: the first part is done by the InLoader and the second part of done by the InCommand component. See also justification to previous requirement.||||
6.1.4.2a|Reporting Successful Acceptance|The acceptance and reporting subservice shall provide the capability to report the successful acceptance verification of requests.|C1|See Operation to Report Acceptance Success (Adaptation Point ILD-13)||||
b||Each successful acceptance verification report shall contain exactly one successful acceptance notification.|C1|See definition of InLoader component: the operation to Report Acceptance Success is called once for each incoming command which passes its acceptance check||||
c||Each successful acceptance notification shall contain: \newline 1. the identifier of the request that successfully passed the acceptance verification.|C1|The specification of the content of the (1,1) reports offered by the PUS Extension of the CORDET Framework follows the PUS||||
d||For each request that successfully passes its acceptance verification, the acceptance and reporting subservice shall: \newline 1. if the successful acceptance reporting is requested, generate a single successful acceptance notification and associated report for that request.|C1|See definition of InLoader component in the CORDET Framework.||||
6.1.4.3a|Reporting failed acceptance|The acceptance and reporting subservice shall provide the capability to report the failed acceptance of requests.|C1|The PUS Extension of the CORDET Framework implements service 1 in full (see requirements P-S1-*).||||
b||Each failed acceptance verification report shall contain exactly one failed acceptance notification.|C1|Each service 1 report provided by the PUS Extension of the CORDET Framework covers one single command failure.||||
c||Each failed acceptance notification shall contain: \newline 1. the identifier of the request that failed the acceptance verification; \newline 2. the failure notice made of: \newline (a) a failure code; \newline (b) auxiliary data, if any, used to explain the reason for the failed acceptance.|C1|The specification of the service 1 reports offered by the PUS Extension of the CORDET Framework follows the PUS||||
d||The list of failure codes defined for failed acceptance notifications shall be declared when specifying the acceptance and reporting subservice.|C1/C2|The failure codes defined at the level of the PUS Extension of the CORDET Framework are defined in requirement P-S1-13 but applications may define additional failure codes.||||
e||For each failure code defined for failed acceptance notifications, the associated auxiliary data shall be declared when specifying the acceptance and reporting subservice.|C1|For each acceptance failure report, one single item of auxiliary data may be defined. For the failure codes supported by the PUS Extension of the CORDET Framework, these are specified in requirement P-S1-13.||||
f||For each request that fails its acceptance verification, the acceptance and reporting subservice shall: \newline 1. generate a single failed acceptance notification and associated report for that request; \newline 2. discard that request.|C1|The generation of the failure notification and the discarding of requests which fail their acceptance check is done by the InLoader component of the CORDET Framework. ||||
6.1.5.1.1a|Reporting successful start of execution|The execution reporting subservice shall provide the capability to generate the successful start of execution verification reports.|C1|The PUS Extension of the CORDET Framework implements service 1 in full (see requirements P-S1-*).||||
b||For each successful start of execution notification that it receives, the execution reporting subservice shall: \newline 1. if the successful start of execution reporting is requested, generate a single successful start of execution verification report containing that notification.|C1|See definition of report component VerStartSucc. Note that  the processing of a incoming command can result in at most one single Successful Start of Execution Notification.||||
6.1.5.1.2a|Reporting failed start of execution|The execution reporting subservice shall provide the capability to generate the failed start of execution verification reports.|C1|The PUS Extension of the CORDET Framework implements service 1 in full (see requirements P-S1-*).||||
b||For each failed start of execution notification that it receives, the execution reporting subservice shall: \newline 1. generate a single failed start of execution verification report containing that notification.|C1|See definition of report component VerStartFailed. Note that a command whose start of execution fails is discarded (i.e. the command terminates with the generation of a (1,4) report). Note also that the processing of a incoming command can result in at most one single Failed Start of Execution Notification.||||
6.1.5.2.1a|Reporting successful progress of execution|The execution reporting subservice shall provide the capability to generate the successful progress of execution verification reports.|C1|The PUS Extension of the CORDET Framework implements service 1 in full (see requirements P-S1-*).||||
b||For each successful progress of execution notification that it receives, the execution reporting subservice shall: \newline 1. if the successful progress of execution reporting is requested, generate a single successful progress of execution verification report containing that notification.|C1/C2|See definition of report component VerPrgrSucc. The definition of the progress steps is under the responsibility of applications (see adaptation point P-S1-7)||||
6.1.5.2.2a|Reporting failed progress of execution|The execution reporting subservice shall provide the capability to generate the failed progress of execution verification reports.|C1|The PUS Extension of the CORDET Framework implements service 1 in full (see requirements P-S1-*).||||
b||For each failed progress of execution notification that it receives, the execution reporting subservice shall: \newline 1. if the application process that hosts the execution reporting subservice is configured for the corresponding request type to report the failed progress of execution notifications in failed progress of execution verification reports, generate a single failed progress of execution verification report containing that notification.|C1|See definition of report component VerPrgrFailed. Note that a command whose progress of execution fails is discarded (i.e. the command terminates with the generation of a (1,6) report).||||
6.1.5.3.1a|Reporting successful completion of execution|The execution reporting subservice shall provide the capability to generate the successful completion of execution verification reports.|C1|The PUS Extension of the CORDET Framework implements service 1 in full (see requirements P-S1-*).||||
b||For each successful completion of execution notification that it receives, the execution reporting subservice shall: \newline 1. if the successful completion of execution reporting is requested, generate a single successful completion of execution verification report containing that notification.|C1|See definition of report component VerTermSucc.||||
6.1.5.3.2a|Reporting failed completion of execution|The execution reporting subservice shall provide the capability to generate the failed completion of execution verification reports.|C1|The PUS Extension of the CORDET Framework implements service 1 in full (see requirements P-S1-*).||||
b||For each failed completion of execution notification that it receives, the execution reporting subservice shall: \newline 1. generate a single failed completion of execution verification report containing that notification.|C1|See definition of report component VerTermFailed.||||
c||For each failed completion of execution notification that is accompanied of failed progress of executions notifications to be reported as part of the completion of execution verification report, the execution reporting subservice shall include those failed progress of execution notifications in the failed completion of execution notification.|TBD|By default, in the PUS Extension of the CORDET Framework, the failure of progress of execution is reported through a (1,6) report and the generation of the (1,6) report excludes the generation of the (1,8) report. See justification of compliance to clause 5.4.9a. \newline \newline NB: The practical implications of this requirement are not understood. Suppose that we have a situation where a command has generated five Failed-Progress-Of-Execution notifications and that it has been agreed that these must be included in the Failed-Completiong-Of-Execution notification. I assume that this means that the TM(1,8) for this command will have to somehow include the five failure codes (and any associated auxiliary data) for the five Failed-Progress-Of-Execution notifications. But how can this be done in view of the fact that the layout of the TM(1,8) in clause 8.1.2.8 only includes one single Failure Notice?||||
6.2|Device Access|Definition of service 2|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.3.2.1.1a|Housekeeping reporting subservice|Each housekeeping service shall contain at least one housekeeping reporting subservice.|C1|The PUS Extension of the CORDET Framework includes support for the reporting subservice||||
6.3.2.1.2a|Diagnostic reporting subservice|Each housekeeping service shall contain zero or more diagnostic reporting subservices.|C1|The PUS Extension of the CORDET Framework includes support for the diagnostic subservice||||
6.3.2.1.3a|Parameter functional reporting configuration subservice|Each housekeeping service shall contain at most one parameter functional reporting configuration subservice.|n.a.|The PUS Extension of the CORDET Framework does not support the parameter functional configuration subservice||||
6.3.2.2.1a|Housekeeping reporting subservice|Each application process shall host at most one housekeeping reporting subservice provider.|C1|The PUS Extension of the CORDET Framework supports one housekeeping reporting subservice per application||||
6.3.2.2.2a|Diagnostic reporting subservice|Each application process shall host at most one diagnostic reporting subservice provider.|C2|The PUS Extension of the CORDET Framework supports one diagnostic reporting subservice per application||||
6.3.2.2.3a|Parameter functional reporting configuration subservice|Each application process shall host at most one parameter functional reporting configuration subservice provider.|n.a.|The PUS Extension of the CORDET Framework does not support the parameter functional configuration subservice||||
6.3.3.1|Parameter accessibility|The housekeeping reporting subservice shall be able to collect and report the sampled values of each on-board parameter that is accessible to the application process that hosts that subservice.|C1|The housekeeping reports report the values of the data items in the data pool which contain all application parameters and variables||||
6.3.3.2a|Housekeeping parameter report structure|The on-board resources allocated to the housekeeping reporting subservice to host the housekeeping parameter report structures shall be declared when specifying that subservice.|C2|The on-board resource dedicated to the housekeeping service is the data pool whose content must be defined by the user during the framework instantiation process (adaptation point P-DP-7). Additionally, the application developer must size the Report Definition List (RDL) data structure by defining the values of the constants HK\_*.||||
b||The on-board resources allocated to the contemporaneous evaluation of housekeeping parameter report structures used by the housekeeping reporting subservice shall be declared when specifying that subservice.|C2|See previous requirement||||
c||Each housekeeping parameter report structure shall consist of: \newline 1. a housekeeping parameter report structure identifier; \newline 2. the collection interval used to generate the corresponding reports; \newline 3. an ordered list of zero or more simply commutated parameters; \newline 4. an ordered list of zero or more super commutated parameter sets, each set consisting of: \newline (a) the number of sampled values to report for each parameter of that set, and \newline (b) the ordered list of one or more parameters contained within that set; \newline if the housekeeping reporting subservice provides the capability for managing the periodic generation of housekeeping parameter reports, a status indicating whether the periodic generation action of the corresponding housekeeping parameter reports is enabled or disabled.|C1|See specification of Report Definition List (RDL)||||
6.3.3.3a|Housekeeping parameter report structure|The housekeeping reporting subservice shall provide the capability for generating housekeeping parameter reports.|C1|The PUS Extension of the CORDET Framework supports reports (3,25)||||
b||Each housekeeping parameter report shall contain exactly one housekeeping parameter notification.|C1|See definition of hkRep component||||
c||Each housekeeping parameter notification shall contain: \newline 1. the housekeeping parameter report structure identifier; \newline 2. in the specified order for simply commutated parameters, a single sampled value for each simply commutated parameter; \newline 3. in the specified order for super commutated parameter sets, for each super commutated parameter set: \newline (a) the 'super commutated sample repetition number' sets of sampled values.|C1|See definition of hkRep component||||
d||For each housekeeping parameter report structure for which periodic generation is enabled, the housekeeping reporting subservice shall generate a corresponding housekeeping parameter report periodically, according to the collection interval specified for that definition.|C1/C2|See definition of HkRep component encapsulating a housekeeping report. Users are responsible for allocating the instances of this component to OutManager components which are executed with a frequency corresponding to the report's collection period.||||
e||For each housekeeping parameter report structure for which periodic generation is enabled, the housekeeping reporting subservice shall collect one sampled value for each simply commutated parameter during the collection interval specified for the corresponding housekeeping parameter report structure.|C1|See definition of hkRep component||||
f||For each housekeeping parameter report structure for which periodic generation is enabled, the housekeeping reporting subservice shall collect all sampled values for each super commutated parameter during the collection interval specified for the corresponding housekeeping parameter report structure, in accordance with a sub-period equal to the collection interval divided by the corresponding 'super commutated sample repetition number'.|C1/C2|The framework provides the Sampling Buffer as a data structure to hold super-commutated data items but the user is responsible for filling it with the sampled values of the super-commutated data items (see requirement P-S3-6)||||
6.3.3.4.1a|Enable the periodic generation of housekeeping parameter reports|The housekeeping reporting subservice capability to enable the periodic generation of housekeeping parameter reports shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports command (3,5)||||
b||Each request to enable the periodic generation of housekeeping parameter reports shall contain one or more instructions to enable the periodic generation of a housekeeping parameter report.|C1|See definition of HkEnable component||||
c||Each instruction to enable the periodic generation of a housekeeping parameter report shall contain: \newline 1. the housekeeping parameter report structure identifier to enable.|C1|See definition of HkEnable component||||
d||The housekeeping reporting subservice shall reject any instruction to enable the periodic generation of a housekeeping parameter report if: \newline 1. that instruction refers to a housekeeping parameter report structure that is unknown.|C1|See definition of Start Action of HkEnable component||||
e||For each instruction to enable the periodic generation of a housekeeping parameter report that it rejects, the housekeeping reporting subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of HkEnable component||||
f||The housekeeping reporting subservice shall process any valid instruction that is contained within a request to enable the periodic generation of housekeeping parameter reports regardless of the presence of faulty instructions.|C1|See definition of Progress Action of HkEnable component||||
g||For each valid instruction to enable the periodic generation of a housekeeping parameter report, the housekeeping reporting subservice shall: \newline 1. set the periodic generation action status of that housekeeping parameter report structure to 'enabled'.|C1|See definition of Progress Action of HkEnable component||||
6.3.3.4.2a|Disable the periodic generation of housekeeping parameter reports|The housekeeping reporting subservice shall provide the capability to disable the periodic generation of housekeeping parameter reports if the capability to enable the periodic generation of housekeeping parameter reports is provided by that subservice.|C1|The PUS Extension of the CORDET Framework supports command (3,6)||||
b||Each request to disable the periodic generation of housekeeping parameter reports shall contain one or more instructions to disable the periodic generation of a housekeeping parameter report.|C1|See definition of HkDisable component||||
c||Each instruction to disable the periodic generation of a housekeeping parameter report shall contain: \newline 1. the housekeeping parameter report structure identifier to disable.|C1|See definition of HkDisable component||||
d||The housekeeping reporting subservice shall reject any instruction to disable the periodic generation of a housekeeping parameter report if: \newline 1. that instruction refers to a housekeeping parameter report structure that is unknown.|C1|See definition of Start Action of HkDisable component||||
e||For each instruction to disable the periodic generation of a housekeeping parameter report that it rejects, the housekeeping reporting subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of HkDisable component||||
f||The housekeeping reporting subservice shall process any valid instruction that is contained within a request to disable the periodic generation of housekeeping parameter reports regardless of the presence of faulty instructions.|C1|See definition of Progress Action of HkDisable component||||
g||For each valid instruction to disable the periodic generation of a housekeeping parameter report, the housekeeping reporting subservice shall: \newline 1. set the periodic generation action status of that housekeeping parameter report structure to 'disabled'.|C1|See definition of Progress Action of HkDisable component||||
6.3.3.5.1a|Create a housekeeping parameter report structure|The housekeeping reporting subservice capability to create a housekeeping parameter report structure shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports command (3,1)||||
b||Each request to create a housekeeping parameter report structure shall contain exactly one instruction to create a housekeeping parameter report structure.|C1|See definition of HkCreate component||||
c||Each instruction to create a housekeeping parameter report structure shall contain: \newline 1. the housekeeping parameter report structure identifier to create; \newline 2. the collection interval; \newline 3. the list of simply commutated parameters in the required order; \newline 4. the list of super commutated parameter sets in the required order.|C1|See definition of HkCreate component||||
d||The housekeeping reporting subservice shall reject any request to create a housekeeping parameter report structure if any of the following conditions occurs: \newline 1. that request contains an instruction that refers to a housekeeping parameter report structure that is already in use; \newline 2. the same parameter is identified more than once in that request; \newline 3. the resources allocated to the hosting of housekeeping parameter report structures are exceeded.|C1|See definition of Start Action of HkCreate component||||
e||For each request to create a housekeeping parameter report structure that is rejected, the housekeeping reporting subservice shall generate a failed start of execution notification.|C1|See definition of Start Action of HkCreate component||||
f||For each valid instruction to create a housekeeping parameter report structure, the housekeeping reporting subservice shall: \newline 1. create that definition; \newline 2. set its periodic generation action status to 'disabled'.|C1|See definition of Progress Action of HkCreate component||||
6.3.3.5.2a|Delete housekeeping parameter report structures|The housekeeping reporting subservice shall provide the capability to delete housekeeping parameter report structures if the capability to create a housekeeping report definition is provided by that subservice.|C1|The PUS Extension of the CORDET Framework supports command (3,3)||||
b||Each request to delete housekeeping parameter report structures shall contain one or more instructions to delete a housekeeping parameter report structure.|C1|See definition of HkDelete component||||
c||Each instruction to delete a housekeeping parameter report structure shall contain: \newline 1. the housekeeping parameter report structure identifier to delete.|C1|See definition of HkDelete component||||
d||The housekeeping reporting subservice shall reject any instruction to delete a housekeeping parameter report structure if any of the following conditions occurs: \newline 1. that instruction refers to a housekeeping parameter report structure that is unknown; \newline 2. that instruction refers to a housekeeping parameter report structure whose periodic generation action status is 'enabled'.|C1|See definition of Start Action of HkDelete component||||
e||For each instruction to delete a housekeeping parameter report structure that it rejects, the housekeeping reporting subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of HkDelete component||||
f||The housekeeping reporting subservice shall process any valid instruction that is contained within a request to delete housekeeping parameter report structures regardless of the presence of faulty instructions.|C1|See definition of Start Action of Progress Action of HkDelete component||||
g||For each valid instruction to delete a housekeeping parameter report structure, the housekeeping reporting subservice shall: \newline  1. delete the housekeeping parameter report structure referred to by that instruction.|C1|See definition of Start Action of Progress Action of HkDelete component||||
6.3.3.6a|Report housekeeping parameter report structures|The housekeeping reporting subservice capability to report housekeeping parameter report structures shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports both command (3,9) and report (3,10)||||
b||Each request to report housekeeping parameter report structures shall contain one or more instructions to report a housekeeping parameter report structure.|C1|See definition of HkRepStructCmd component||||
c||Each instruction to report a housekeeping parameter report structure shall contain: \newline  1. the housekeeping parameter report structure identifier to report.|C1|See definition of HkRepStructCmd component||||
d||The housekeeping reporting subservice shall reject any instruction to report a housekeeping parameter report structure if: \newline 1. that instruction refers to a housekeeping parameter report structure that is unknown.|C1|See definition of Start Action of HkRepStructCmd component||||
e||For each instruction to report a housekeeping parameter report structure that it rejects, the housekeeping reporting subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of HkRepStructCmd component||||
f||The housekeeping reporting subservice shall process any valid instruction that is contained within a request to report housekeeping parameter report structures regardless of the presence of faulty instructions.|C1|See definition of Progress Action of HkRepStructCmd component||||
g||For each valid instruction to report a housekeeping parameter report structure, the housekeeping reporting subservice shall generate a single housekeeping parameter report structure report that contains exactly one housekeeping parameter report structure notification that includes: \newline 1. the housekeeping parameter report structure identifier; \newline 2. If the housekeeping reporting subservice provides the capability for managing the periodic generation of housekeeping parameter reports, the periodic generation action status; \newline 3. the collection interval; \newline 4. the ordered list of simply commutated parameters; \newline 5. the ordered list of super commutated parameter sets. 86|C1|See definition of Progress Action of HkRepStructCmd component and definition of HkRepStructRep component. With respect to point 2, it is noted that the periodic generation of housekeeping reports is supported by the service 3 implementation of the PUS Extension of the CORDET Framework||||
6.3.3.7a|Generate a one shot report for housekeeping parameter report structures|The housekeeping reporting subservice capability to generate a one shot report for housekeeping parameter report structures shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports both command (3,27) and report (3,25)||||
b||Each request to generate a one shot report for housekeeping parameter report structures shall contain one or more instructions to generate a one shot report for a housekeeping parameter report structure.|C1|See definition of HkOneShotRep component||||
c||Each instruction to generate a one shot report for a housekeeping parameter report structure shall contain: \newline 1. the housekeeping parameter report structure identifier of the report to generate.|C1|See definition of HkOneShotRep component||||
d||The housekeeping reporting subservice shall reject any instruction to generate a one shot report for a housekeeping parameter report structure if: \newline 1. that instruction refers to a housekeeping parameter report structure that is unknown.|C1|See definition of Start Action of HkOneShotRep component||||
e||For each instruction to generate a one shot report for a housekeeping parameter report structure that it rejects, the housekeeping reporting subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of HkOneShotRep component||||
f||The housekeeping reporting subservice shall process any valid instruction that is contained within a request to generate a one shot report for housekeeping parameter report structures regardless of the presence of faulty instructions.|C1|See definition of Progress Action of HkOneShotRep component||||
g||For each valid instruction to generate a one shot report for a housekeeping parameter report structure, the housekeeping reporting subservice shall generate a single housekeeping parameter report.|C1|See definition of Progress Action of HkOneShotRep component||||
6.3.3.8|Append parameters to a housekeeping parameter report structure||n.a.|This capability is not supported by the PUS Extension of the CORDET Framework||||
6.3.3.9|Modify the collection interval of housekeeping parameter report structures||n.a.|This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.3.310|Report the periodic generation properties of housekeeping parameter report structures||n.a.|This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.3.4|Diagnostic reporting subservice||C1/C2|The components offerd by the PUS Extension to implement housekeeping-related capabilities also implement the corresponding diagnostic-related capability. Hence, the level of compliance to the diagnostic reporting subservice requirements is the same as the level of compliance to the homologous housekeeping reporting sub-service requirements.||||
6.3.5|Parameter functional reporting configuration subservice||n.a.|This subservice is not supported by the PUS Extension of the CORDET Framework||||
6.4|Parameter Statistics Reporting|Definition of service 4|n.a.|This service is not supported by the PUS Extension of the CORDET Framework||||
6.5|Event Reporting|Definition of service 5||||||
6.5.2.1.1a|Event reporting subservice|Each event reporting service shall contain at least one event reporting subservice.|C1|The PUS Extension of the CORDET Framework supports service 5 in full||||
6.5.2.2a|Application process|Each application process shall host at most one event reporting subservice provider.|C1|An application instantiated from the CORDET Framework can only provide one instance of a service of a given type and of its sub-services||||
6.5.3a|Event Definition|The list of events that can be detected by the event reporting subservice shall be declared when specifying that subservice.|C2|The set of events that can be reported by the service 5 implementation of the PUS Extension of the CORDET Framework is an adaptation point (see table \ref{tab:CR-S5-1})||||
b||For each event that can be detected by the event reporting subservice, the event definition used to report on the occurrences of that event, the related event severity level, the event definition identifier and, if any, auxiliary data shall be declared when specifying that subservice.|C2|Application developers must provide this information in order to define the EvtRep components which encapsulate their event reports (see table \ref{tab:CR-S5-1})||||
c||Each event definition shall be uniquely identified by the combination of the identifier of the application process that hosts the event reporting subservice provider that is in charge to report on the occurrences of the associated event and an event definition identifier.|C2|Both the definition of the APIDs and of the EIDs are under the responsibility of application developers ||||
6.5.4a|Event Reporting|The event reporting subservice shall provide the capability to generate event reports.|C1|See definition of the EvtRep component in table \ref{tab:CR-S5-1}||||
b||The destination of the event reports generated by the event reporting subservice shall be declared when specifying that subservice.|C2|The destination of an event report must be specified by an application at run-time when the event is configured. See definition of EvtRep component in table \ref{tab:CR-S5-1}||||
c||If the event reporting subservice supports the capability for controlling the generation of event reports specified in clause 6.5.5, that subservice shall generate an event notification whenever it detects the occurrence of an event associated to an event definition for which event report generation is enabled.|C1|The PUS Extension of the CORDET Framework provides the capability to enable and disable event reports (see definition of EvtEnableCmd and EvtDisableCmd components)||||
d||If the event reporting subservice does not support the capability for controlling the generation of event reports specified in clause 6.5.5, that subservice shall generate an event notification whenever it detects the occurrence of an event.|n.a.|See previous requirement||||
e||Each event notification shall contain: \newline 1. the event definition identifier of the associated event definition; \newline 2. the auxiliary data associated to that event definition, if any.|C1|See definition of the EvtRep component||||
f||For each event notification that it generates, the event reporting subservice shall generate an event report of the related event severity level, which contains that notification.|C1|The event notification is encapsulated in the EvtRep component. The processing of this component by the CORDET Framework results in the generation of the corresponding event report||||
6.5.5.1a|Event report generation status|For each event that can be detected by the event reporting subservice, the subservice shall maintain a status indicating whether the event report generation for that event is enabled or disabled.|C1|The CORDET Framework provides the capability to track the enable status of any out-going command or report (see OutRegistry component in [CR-SP])||||
b||For each event that can be detected by the event reporting subservice, the initial enabled or disabled event report generation status shall be declared when specifying that subservice.|C1/C2|The default enable status of all out-going commands or reports in the CORDET Framework is: 'enabled'. A different initial value can be achieved by configuring the OutRegistry during the application initialization phase.||||
6.5.5.2a|Enable the report generation of event definitions|The event reporting subservice capability to enable the report generation of event definitions shall be declared when specifying that subservice.|C1|The PUS Extension supports command (5,5)||||
b||Each request to enable the report generation of event definitions shall contain one or more instructions to enable the report generation of an event definition.|C1|See definition of the EvtEnableCmd component||||
c||Each instruction to enable the report generation of an event definition shall contain: \newline 1. the event definition identifier of the event definition to enable.|C1|See definition of the EvtEnableCmd component||||
d||The event reporting subservice shall reject any instruction to enable the report generation of an event definition if: \newline 1. that instruction refers to an unknown event definition.|C1|See definition of Start Action of EvtEnableCmd component||||
e||For each instruction to enable the report generation of an event definition that it rejects, the event reporting subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of EvtEnableCmd component||||
f||The event reporting subservice shall process any valid instruction that is contained within a request to enable the report generation of event definitions regardless of the presence of faulty instructions.|C1|See definition of the EvtEnableCmd component||||
g||For each valid instruction to enable the report generation of an event definition, the event reporting subservice shall: set the event report generation status of the event definition to enabled.|C1|See definition of Progress Action of EvtEnableCmd component||||
6.5.5.3a|Disable the report generation of event definitions|The event reporting subservice shall provide the capability to disable the report generation of event definitions if the capability to enable the report generation of event definitions is provided by that subservice.|C1|The PUS Extension supports command (5,6)||||
b||Each request to disable the report generation of event definitions shall contain one or more instructions to disable the report generation of an event definition.|C1|See definition of the EvtDisableCmd component||||
c||Each instruction to disable the report generation of an event definition shall contain: \newline 1. the event definition identifier of the event definition to disable.|C1|See definition of the EvtDisableCmd component||||
d||The event reporting subservice shall reject any instruction to disable the report generation of an event definition if: \newline 1. that instruction refers to an unknown event definition.|C1|See definition of Start Action of EvtDisableCmd component||||
e||For each instruction to disable the report generation of an event definition that it rejects, the event reporting subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of EvtDisableCmd component||||
f||The event reporting subservice shall process any valid instruction that is contained within a request to disable the report generation of event definitions regardless of the presence of faulty instructions.|C1|See definition of the EvtDisableCmd component||||
g||For each valid instruction to disable the report generation of an event definition, the event reporting subservice shall: set the event report generation status of the event definition to disabled.|C1|See definition of Progress Action of EvtDisableCmd component||||
6.5.5.4a|Report the list of disabled event definitions|The event reporting subservice capability to report the list of disabled event definitions shall be declared when specifying that subservice.|C1|The PUS Extension supports command (5,7)||||
b||Each request to report the list of disabled event definitions shall contain exactly one instruction to report the list of disabled event definitions.|C1|See definition of the EvtRepDisabledCmd component||||
c||For each valid instruction to report the list of disabled event definitions, the event reporting subservice shall: generate, for each event definition whose event report generation status is disabled, a single disabled event definition notification that includes:the related event definition identifier.|C1|See definition of the EvtRepDisabledCmd component||||
d||For each valid request to report the list of disabled event definitions, the event reporting subservice shall generate a single disabled event definitions list report that includes all related disabled event definition notifications.|C1|See definition of the EvtRepDisabledCmd and EvtRepDisabledRep components||||
6.5.6|Subservice observables|The following observables shall be defined for the event reporting subservice: \newline 1. per severity level: \newline (a) the accumulated number of detected event occurrences, \newline (b) the number of event definitions whose event report generation status is disabled, \newline (c) the accumulated number of generated event reports, \newline (d) the event definition identifier of the last generated event Report, \newline (e) the generation time of the last event report.|C1|See definition of Observable Data Items associated to service 5||||
6.6|Memory Management|Definition of service 6|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.8|Function Management|Definition of service 8|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.9|Time Management|Definition of service 9|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.11|Time-Base Scheduling|Definition of service 11||||||
6.11.2.1.1a|Time-based scheduling subservice|Each time-based scheduling service shall contain at least one time-based scheduling subservice.|C1|The PUS Extension of the CORDET Framework supports the time-based scheduling sub-service and it allows one instance of the service to be deployed in an application. The service only contains one instance of its sub-service.||||
6.11.2.2a|Application process|Each application process shall host at most one time-based scheduling subservice provider.|C1|See statement of compliance to previous clause||||
6.11.3.1a|Application process|The list of application processes that can be addressed by the time-based scheduling subservice when releasing requests shall be declared when specifying that subservice.|C1|TBD||||
6.11.4.1a|Capability|Whether the time-based scheduling subservice supports the capability for managing sub-schedules shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the sub-schedule concept||||
b||Whether the time-based scheduling subservice supports the capability for managing groups specified shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the group concept||||
6.11.4.2a|General|Each scheduled activity definition shall consist of: 1. the request; 2. the release time of that request; 3. if sub-schedules are supported, the identifier of the sub-schedule to which that scheduled activity is associated; 4. if groups are supported, the identifier of the group to which that scheduled activity is associated.|C1|See definition of attributes of a time-based activity or TBA||||
b||Each scheduled activity definition shall be identified by a scheduled activity identifier that corresponds to the identifier of the request contained in that definition.|C1|A scheduled activity is identified by an integer in the range from 1 to SCD\_N\_TBA. The identifier of the request in the TBA (source, destination and source sequence counter of the request) can be reconstructed from the information in the TBA which includes a pointer to the InCommand encapsulating the request.||||
c||The maximum number of scheduled activity definitions that the time-based scheduling subservice can insert within the time-based schedule and contemporaneously process at any time shall be declared when specifying that subservice.|C2|This is given by SCD\_N\_TBA||||
d||The time margin that the time-based scheduling subservice uses when inserting activities in the time-based schedule or time-shifting activities shall be declared when specifying that subservice.|C1|The time-margin is one of the parameters associated to the time-based scheduling service||||
e||The maximum delta time between the release time specified in a scheduled activity definition and the real release time of the related request shall be declared when specifying that subservice.|C2|This delta-time depends on how frequently the TBS is processed by the host application and on how frequently commands and processed by the host application. Both items are defined by the application designer as part of the instantiation process of the PUS Extension of the CORDET Framework||||
6.11.4.3.1a|Status|The time-based scheduling subservice shall maintain a status indicating whether the overall time-based schedule execution function is enabled or disabled.|C1|The PUS Extension of the CORDET Framework supports the (11,1) and (11,2) commands and defines the enable status of the TBS as a service 11 observable||||
b||When starting the time-based scheduling subservice, the time-based schedule execution function status shall be set to disabled.|C1|The default enable status of the TBS is: disabled||||
6.11.4.3.2a|Enable the time-based schedule execution function|The time-based scheduling subservice shall provide the capability to enable the time-based schedule execution function.|C1|The PUS Extension of the CORDET Framework supports command (11,1)||||
b||Each request to enable the time-based schedule execution function shall contain exactly one instruction to enable the time-based schedule execution function.|C1|See definition of component ScdEnbTbs||||
c||"For each valid instruction to enable the time-based schedule execution
function, the time-based scheduling subservice shall: 1. set the time-based schedule execution function status to enabled."|C1|See definition of progress action of component ScdEnbTbs||||
6.11.4.3.3a|Disable the time-based schedule execution function|The time-based scheduling subservice shall provide the capability to disable the time-based schedule execution function.|C1|The PUS Extension of the CORDET Framework supports command (11,2)||||
b||Each request to disable the time-based schedule execution function shall contain exactly one instruction to disable the time-based schedule execution function.|C1|See definition of component ScdDisTbs||||
c||"For each valid instruction to disable the time-based schedule execution
function, the time-based scheduling subservice shall: 1. set the time-based schedule execution function status to disabled."|C1|See definition of progress action of component ScdDisTbs||||
6.11.4.4a|Reset the time-based schedule|The time-based scheduling subservice shall provide the capability to reset the time-based schedule.|C1|The PUS Extension of the CORDET Framework supports command (11,3)||||
b||Each request to reset the time-based schedule shall contain exactly one instruction to reset the time-based schedule.|C1|See definition of component ScdResTbs||||
c||"For each valid instruction to reset the time-based schedule, the time-based scheduling subservice shall: 1. set the time-based schedule execution function status to ""disabled""; 2. delete all scheduled activities from the schedule; 3. if sub-schedules are supported, delete all sub-schedules; 4. if groups are supported, enable all groups."|C1|See definition of progress action of component ScdResTbs||||
6.11.4.5a|Insert activities into the time-based schedule|The time-based scheduling subservice shall provide the capability to insert activities into the time-based schedule.|C1|The PUS Extension of the CORDET Framework supports command (11,4)||||
b||Each request to insert activities into the time-based schedule shall contain: 1. if sub-schedules are supported, the sub-schedule identifier; 2. one or more instructions to insert an activity into the time-based schedule.|C1|See definition of component ScdInsTbs. Note that sub-schedules are supported.||||
c||The time-based scheduling subservice shall reject any request to insert activities into the time-based schedule if: 1. that request implies the creation of a new sub-schedule but the maximum number of sub-schedules that can be contemporaneously managed is already reached.|C1|See definition of Start Action of command ScdInsTba.||||
d||For each request to insert activities into the time-based schedule that is rejected, the time-based scheduling subservice shall generate a failed start of execution notification.|C1|See definition of Start Action of command ScdInsTba.||||
e||Each instruction to insert an activity into the time-based schedule shall contain: 1. if groups are supported, the group identifier associated to the new scheduled activity; 2. the release time of that new scheduled activity; 3. the request associated to that new scheduled activity.|C1|See definition of component ScdInsTbs. Note that groups are supported.||||
f||The list of verification checks that the time-based scheduling subservice shall perform on the requests associated to the new scheduled activities shall be declared when specifying that subservice.|C1|See definition of Start Action of command ScdInsTba.||||
g||The time-based scheduling subservice shall reject any instruction to insert an activity into the time-based schedule if any of the following conditions occurs: 1. the activity cannot be added since the maximum number of scheduled activities that can be contemporaneously processed is already reached; 2. the release time of the activity is earlier than the time obtained by adding the time-based schedule time margin to the current time; 3. that instruction refers to a group that is unknown; 4. the request contained in that instruction fails any of the verification checks.|C1|See definition of Start Action of command ScdInsTba.||||
h||For each instruction to insert an activity into the time-based schedule that it rejects, the time-based scheduling subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of command ScdInsTba.||||
I||The time-based scheduling subservice shall process any valid instruction that is contained within a request to insert activities into the time-based schedule regardless of the presence of faulty instructions.|C1|See definition of Start Action of command ScdInsTba.||||
j||For each valid request to insert activities into the time-based schedule, the time-based scheduling subservice shall: 1. if sub-schedules are supported and the sub-schedule specified in that request is unknown: (a) create that sub-schedule; (b) set its status to disabled.|C1|See definition of Progress Action of command ScdInsTba. Note that, in the context of the PUS Extension, to create a sub-schedule means to set is inUse flag to true. ||||
l||For each valid instruction to insert an activity into the time-based schedule, the time-based scheduling subservice shall: 1. create a new scheduled activity in the schedule; 2. place the request specified in that instruction into the new scheduled activity; 3. set the release time of the new scheduled activity to the release time specified in that instruction; 4. if sub-schedules are supported, associate the new scheduled activity to the sub-schedule specified in that instruction; 5. if groups are supported, associate the new scheduled activity to the group specified in that instruction.|C1|See definition of Progress Action of command ScdInsTba. ||||
6.11.4.6a|Schedule execution logic|The time-based schedule execution process shall process the scheduled activities in the order of their release times.|C1|See definition of Time-Based Schedule Execution Procedure||||
b||"The time-based schedule execution process shall consider a scheduled activity is disabled if any of the following conditions occurs: 1. the time-based schedule execution function status is ""disabled""; 2. that scheduled activity is associated to a disabled sub-schedule; 3. that scheduled activity is associated to a disabled group"|C1|See definition of Time-Based Schedule Execution Procedure||||
c||For each scheduled activity whose release time is reached, the time-based schedule execution process shall, in sequence: 1. if that scheduled activity is not disabled, release the related request; 2. delete that scheduled activity from the schedule; 3. if that scheduled activity was the last scheduled activity of a sub-schedule, delete the sub-schedule|C1|See definition of Time-Based Schedule Execution Procedure||||
6.11.5.1a|Time-based sub-schedules|The maximum number of sub-schedules that the time-based scheduling subservice can contemporaneously manage shall be declared when specifying that subservice.|C1|See definition of observables associated to service 11. ||||
||For each sub-schedule, the time-based scheduling subservice shall maintain a status indicating whether the schedule execution function for that sub-schedule is enabled or disabled.|C1|See definition of observables associated to service 11. ||||
6.11.5.2.1a|Enable time-based sub-schedules|The time-based scheduling subservice capability to enable time-based sub-schedules shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports command (11,20)||||
b||Each request to enable time-based sub-schedules shall contain: 1. one or more instructions to enable a time-based sub-schedule, or 2. exactly one instruction to enable all time-based sub-schedules.|C1|See definition of component ScdEnbSubSched||||
c||Each instruction to enable a time-based sub-schedule shall contain: 1. the identifier of the sub-schedule to enable.|C1|See definition of component ScdEnbSubSched||||
d||The time-based scheduling subservice shall reject any instruction to enable a time-based sub-schedule if: 1.that instruction refers to an unknown sub-schedule.|C1|See definition of Start Action of command ScdEnbSubSched. A sub-schedule identifier is regarded as unknown if it is illegal or if the associated sub-schedule is empty (which means that it is not being used)||||
e||For each instruction to enable a time-based sub-schedule that it rejects, the time-based scheduling subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of command ScdEnbSubSched. ||||
f||The time-based scheduling subservice shall process any valid instruction that is contained within a request to enable time-based sub-schedules regardless of the presence of faulty instructions.|C1|See definition of Progress Action of command ScdEnbSubSched. ||||
g||For each valid instruction to enable a time-based sub-schedule, the time-based scheduling subservice shall: 1. set the status of that sub-schedule to enabled.|C1|See definition of Progress Action of command ScdEnbSubSched. ||||
h||For each valid instruction to enable all time-based sub-schedules, the time-based scheduling subservice shall: 1. for each sub-schedule maintained by the subservice, set its status to enabled.|C1|See definition of Progress Action of command ScdEnbSubSched. ||||
6.11.5.2.2a|Disable time-based sub-schedules|The time-based scheduling subservice capability to disable time-based sub-schedules shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports command (11,21)||||
b||Each request to disable time-based sub-schedules shall contain: 1. one or more instructions to disable a time-based sub-schedule, or 2. exactly one instruction to disable all time-based sub-schedules.|C1|See definition of component ScdDisSubSched||||
c||Each instruction to disable a time-based sub-schedule shall contain: 1. the identifier of the sub-schedule to disable.|C1|See definition of component ScdDisSubSched||||
d||The time-based scheduling subservice shall reject any instruction to disable a time-based sub-schedule if: 1.that instruction refers to an unknown sub-schedule.|C1|See definition of Start Action of command ScdDisSubSched. A sub-schedule identifier is regarded as unknown if it is illegal or if the associated sub-schedule is empty (which means that it is not being used)||||
e||For each instruction to disable a time-based sub-schedule that it rejects, the time-based scheduling subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of command ScdDisSubSched. ||||
f||The time-based scheduling subservice shall process any valid instruction that is contained within a request to disable time-based sub-schedules regardless of the presence of faulty instructions.|C1|See definition of Progress Action of command ScdDisSubSched. ||||
g||For each valid instruction to disable a time-based sub-schedule, the time-based scheduling subservice shall: 1. set the status of that sub-schedule to disable.|C1|See definition of Progress Action of command ScdDisSubSched. ||||
h||For each valid instruction to disable all time-based sub-schedules, the time-based scheduling subservice shall: 1. for each sub-schedule maintained by the subservice, set its status to disable.|C1|See definition of Progress Action of command ScdDisSubSched. ||||
6.11.5.2.3|Report the status of each time-based sub-schedule|||This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.11.6.1a|Time-base scheduling groups|The maximum number of groups that the time-based scheduling subservice can contemporaneously manage shall be declared when specifying that subservice.|C1|See definition of constants associated to service 11. The value of the constants is defined when the service is instantiated.||||
b||For each group, the time-based scheduling subservice shall maintain a status indicating whether the schedule execution function for that group is enabled or disabled.|C1|See definition of observables associated to service 11||||
6.11.6.2.1a|Create time-based scheduling groups|The time-based scheduling subservice capability to create time-based scheduling groups shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports command (11,22)||||
b||Each request to create time-based scheduling groups shall contain one or more instructions to create a time-based scheduling group.|C1|See definition of command ScdCreGrp||||
c||Each instruction to create a time-based scheduling group shall contain: 1. the identifier of the group; 2. the group status at creation time.|C1|See definition of command ScdCreGrp||||
d||The time-based scheduling subservice shall reject any instruction to create a time-based scheduling group if any of the following conditions occurs: 1. that instruction refers to an already existing group; 2. the maximum number of groups that can be contemporaneously managed is already reached.|C1|See definition of Start Action of command ScdCreGrp||||
e||For each instruction to create a time-based scheduling group that it rejects, the time-based scheduling subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of command ScdCreGrp||||
f||The time-based scheduling subservice shall process any valid instruction that is contained within a request to create time-based scheduling groups regardless of the presence of faulty instructions.|C1|See definition of Progress Action of command ScdCreGrp||||
g||For each valid instruction to create a time-based scheduling group, the time-based scheduling subservice shall: 1. add the group identifier to the list of groups maintained by that sub-service; 2. set the group status to the value specified in the instruction.|C1|See definition of Progress Action of command ScdCreGrp||||
6.11.6.2.2a|Delete time-based scheduling groups|The time-based scheduling subservice shall provide the capability to delete time-based scheduling groups if the capability to create time-based scheduling groups is provided by that subservice.|C1|The PUS Extension of the CORDET Framework supports command (11,23)||||
b||Each request to delete time-based scheduling groups shall contain: 1. one or more instructions to delete a time-based scheduling group, or 2. exactly one instruction to delete all time-based scheduling groups.|C1|See definition of command ScdDelGrp||||
c||Each instruction to delete a time-based scheduling group shall contain: the identifier of the group to be deleted|C1|See definition of command ScdDelGrp||||
d||The time-based scheduling subservice shall reject any instruction to delete a time-based scheduling group if any of the following conditions occurs: 1. that instruction refers to a group that does not exist; 2. that instruction refers to a group that has associated activities.|C1|See definition of Start Action of command ScdDelGrp||||
e||For each instruction to delete a time-based scheduling group that it rejects, the time-based scheduling subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of command ScdDelGrp||||
f||The time-based scheduling subservice shall process any valid instruction that is contained within a request to delete time-based scheduling groups regardless of the presence of faulty instructions.|C1|See definition of Start Action of command ScdDelGrp||||
g||For each valid instruction to delete a time-based scheduling group, the time-based scheduling subservice shall: 1.delete the group identifier from the list of groups maintained by that subservice.|C1|See definition of Progress Action of command ScdDelGrp||||
h||For each valid instruction to delete all time-based scheduling groups, the time-based scheduling subservice shall: 1. for each group that has no associated activity, delete the identifier of that group; 2. for each group that has associated activities, generate a failed execution notification for that group.|C1|See definition of Progress Action of command ScdDelGrp||||
6.11.6.3.1a|Enable time-based scheduling groups|The time-based scheduling subservice shall provide the capability to enable time-based scheduling groups if the capability to create time-based scheduling groups is provided by that subservice.|C1|The PUS Extension of the CORDET Framework supports command (11,24)||||
b||Each request to enable time-based scheduling groups shall contain: 1. one or more instructions to enable a time-based scheduling group, or 2. exactly one instruction to enable all time-based scheduling groups.|C1|See definition of command ScdEnbGrp||||
c||Each instruction to enable a time-based scheduling group shall contain: 1. the identifier of the group to enable.|C1|See definition of command ScdEnbGrp||||
d||The time-based scheduling subservice shall reject any instruction to enable a time-based scheduling group if: 1. that instruction refers to an unknown group.|C1|See definition of Start Action of command ScdEnbGrp||||
e||For each instruction to enable a time-based scheduling group that it rejects, the time-based scheduling subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of command ScdEnbGrp||||
f||The time-based scheduling subservice shall process any valid instruction that is contained within a request to enable time-based scheduling groups regardless of the presence of faulty instructions.|C1|See definition of Progress Action of command ScdEnbGrp||||
g||For each valid instruction to enable a time-based scheduling group, the time-based scheduling subservice shall: 1. set the status of that group to enabled.|C1|See definition of Progress Action of command ScdEnbGrp||||
h||"For each valid instruction to enable all time-based scheduling groups, the time-based scheduling subservice shall: 1.for each group maintained by that subservice, set its status to
Enabled."|C1|See definition of Progress Action of command ScdEnbGrp||||
6.11.6.3.2a|Disable time-based scheduling groups|The time-based scheduling subservice shall provide the capability to disable time-based scheduling groups if the capability to create time-based scheduling groups is provided by that subservice.|C1|The PUS Extension of the CORDET Framework supports command (11,25)||||
b||Each request to enable time-based scheduling groups shall contain: 1. one or more instructions to disable a time-based scheduling group, or 2. exactly one instruction to disable all time-based scheduling groups.|C1|See definition of command ScdDisGrp||||
c||Each instruction to disable a time-based scheduling group shall contain: 1. the identifier of the group to disable.|C1|See definition of command ScdDisGrp||||
d||The time-based scheduling subservice shall reject any instruction to disable a time-based scheduling group if: 1. that instruction refers to an unknown group.|C1|See definition of Start Action of command ScdDisGrp||||
e||For each instruction to disable a time-based scheduling group that it rejects, the time-based scheduling subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of command ScdDisGrp||||
f||The time-based scheduling subservice shall process any valid instruction that is contained within a request to disable time-based scheduling groups regardless of the presence of faulty instructions.|C1|See definition of Progress Action of command ScdDisGrp||||
g||For each valid instruction to disable a time-based scheduling group, the time-based scheduling subservice shall: 1. set the status of that group to disabled.|C1|See definition of Progress Action of command ScdDisGrp||||
h||"For each valid instruction to disable all time-based scheduling groups, the time-based scheduling subservice shall: 1.for each group maintained by that subservice, set its status to
Disabled."|C1|See definition of Progress Action of command ScdDisGrp||||
6.11.6.3.3a|Report the status of each time-based scheduling group|The time-based scheduling subservice capability to report the status of each time-based scheduling group shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports command (11,26) and report (11,27)||||
b||Each request to report the status of each time-based scheduling group shall contain exactly one instruction to report the status of each time-based scheduling group.|C1|See definition of command ScdRepGrp||||
c||For each valid instruction to report the status of each time-based scheduling group, the time-based scheduling subservice shall: generate, for each group managed by the time-based scheduling subservice, a single time-based scheduling group status notification that includes:(a) the group identifier; (b) its status.|C1|See definition of Progress Action of command ScdRepGrp and definition of report ScdGrpRep||||
d||For each valid request to report the status of each time-based scheduling group, the time-based scheduling subservice shall generate a single time-based scheduling group status report that includes all related time-based scheduling group status notifications.|C1|See definition of Progress Action of command ScdRepGrp and definition of report ScdGrpRep||||
6.11.7|Reports of time-based scheduled activities|||This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.11.8.1a|Time-shift all scheduled activities|The time-based scheduling subservice capability to time-shift all scheduled activities shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports command (11,15)||||
b||Each request to time-shift all scheduled activities shall contain exactly one instruction to time-shift all scheduled activities.|C1|See definition of component ScdTimeShiftTbs||||
c||Each instruction to time-shift all scheduled activities shall contain: a time offset, positive or negative, to add to the release time of all scheduled activities.|C1|See definition of component ScdTimeShiftTbs||||
d||The time-based scheduling subservice shall reject any request to time-shift all scheduled activities if: the time obtained by adding the time offset to the release time of the earliest activity contained within the time-based schedule is earlier than the time obtained by adding the time-based schedule time margin to the current time.|C1|See definition of Start Action of component ScdTimeShiftTbs||||
e||For each request to time-shift all scheduled activities that is rejected, the time-based scheduling subservice shall generate a failed start of execution notification.|C1|See definition of Start Action of component ScdTimeShiftTbs||||
f||For each valid instruction to time-shift all scheduled activities, the time-based scheduling subservice shall: for each scheduled activity contained within the time-based schedule: set the release time of that scheduled activity to the sum of the current release time of that activity and the time offset.|C1|See definition of Progress Action of component ScdTimeShiftTbs||||
6.11.8.2.|Summary-report all time-based scheduled activities|||This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.11.8.3|Detail-report all time-based scheduled activities|||This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.11.9|General|Whether the time-based scheduling subservice supports the identification of scheduled activities by request identifier shall be declared when specifying that subservice|C1|This capability is supported. The request identifier is made up of the triplet: request identifier, APID, source sequence counter. One of the attributes of a TBA is the InCommand which encapsulates the TBAâ€™s request. The three elements of the request identifier can be retrieved from the InCommand.||||
6.11.9.1a|Delete time-based scheduled activities identified by request identifier|The time-based scheduling subservice capability to delete time-based scheduled activities identified by request identifier shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports command (11,5)||||
b||Each request to delete time-based scheduled activities identified by request identifier shall contain one or more instructions to delete a time-based scheduled activity identified by request identifier.|C1|See definition of component ScdDelTba||||
c||Each instruction to delete a time-based scheduled activity identified by request identifier shall contain: the identifier of the scheduled activity to delete.|C1|See definition of component ScdDelTba||||
d||The time-based scheduling subservice shall reject any instruction to delete a time-based scheduled activity identified by request identifier if: that instruction contains a request identifier is unknown.|C1|See definition of component ScdDelTba||||
e||For each instruction to delete a time-based scheduled activity identified by request identifier that it rejects, the time-based scheduling subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of ScdDelTba||||
f||The time-based scheduling subservice shall process any valid instruction that is contained within a request to delete time-based scheduled activities identified by request identifier regardless of the presence of faulty instructions.|C1|See definition of Progress Action of ScdDelTba||||
g||For each valid instruction to delete a time-based scheduled activity identified by request identifier, the time-based scheduling subservice shall: 1. delete the scheduled activity corresponding to the request identifier; 2. if that scheduled activity was the last scheduled activity of a sub-schedule, delete the sub-schedule.|C1|See definition of Progress Action of ScdDelTba||||
6.11.9.3|Time-shift scheduled activities identified by request Identifier|||This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.11.9.4|Summary-report time-based scheduled activities identified by request identifier|||This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.11.9.5|Detail-report time-based scheduled activities identified by request identifier|||This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.11.10|Managing the time-based scheduled activities identified by a filter|||This capability is not yet supported by the PUS Extension of the CORDET Framework||||
6.1.1.11a|System Observables|The following observables shall be defined for the time-based scheduling subservice: 1. the time-based schedule execution function status (enabled or disabled); 2. the current number of scheduled activities in the time-based schedule; 3. if sub-schedules are supported, the current number of sub-schedules; 4. if groups are supported, the current number of groups.|C1|See definition of observables associated to service 11. The number of sub-schedules and the number of groups are implemented as the numbers of non-empty sub-schedules and the number of non-empty groups.||||
6.12|On-Board Monitoring|Definition of service 12||||||
6.12.2.1.1a|Parameter Monitoring Subservice|Each on-board monitoring service shall contain exactly one parameter monitoring subservice.|C1|The PUS Extension of the CORDET Framework supports both sub-services of the On-Board Monitoring service and it allows one instance of the service to be deployed in an application. The service only contains one instance of each of its two sub-services.||||
6.12.2.1.2a|Functional Monitoring Subservice|Each on-board monitoring service shall contain at most one functional monitoring subservice.|C1|See statement of compliance to previous clause||||
6.12.2.2a|Application process|For each on-board monitoring service that contains both, a parameter monitoring subservice and a functional monitoring subservice, the two subservice providers of that service shall be hosted by the same application process.|C2|In the CORDET Framework, the allocation of sub-services to application processes is done during the framework instantiation process when the application developers define the groups (see section 4.2 of [PX-SP]||||
6.12.2.3.1a|Service|Each on-board monitoring service shall be associated to exactly one event reporting subservice.|C1|The PUS Extension of the CORDET Framework supports one on-board monitoring service and one event reporting subservice. The former service is associated to the latter subservice.||||
b||The event reporting subservice that is associated to the on-board monitoring service shall be declared when specifying that on-board monitoring service.|C1|See statement of compliance to previous clause||||
6.12.3.1|Parameter accessibility|The parameter monitoring subservice shall be able to monitor all on- board parameters that are accessible to the application process that hosts the subservice.|C1|The parameter monitoring subservice has access to all data pool parameters and variables||||
6.12.3.2.1a| Minimum capability|The parameter monitoring subservice shall support the evaluation of the following minimum check types: 1. Limit-check, 2. Expected-value-check|C1|Both check types are supported. See requirements S13-3 and 4.||||
b||When performing a limit-check, the parameter monitoring subservice shall: 1. check that the value of a parameter lies within a pair of limit values; 2. declare the check successful when the value of the parameter is less than or equal to the high limit value and greater than or equal to the low limit value.|C1|See definition of Limit Check Monitoring Procedure||||
c||When performing an expected-value-check, the parameter monitoring subservice shall: 1. check that the value resulting from applying a bit mask to a parameter is equal to the expected value; 2. declare the check successful when these two values are equal.|C1|See definition of Expected Value Monitoring Procedure||||
6.12.3.2.2a| Additional capability|The parameter monitoring subservice may support the evaluation of the delta-check type.|C1|This check is supported. See requirement S13-5||||
b||Whether the parameter monitoring subservice supports the delta-check type shall be declared when specifying that subservice.|C1|This check is supported. See requirement S13-5||||
c||When performing a delta-check, the parameter monitoring subservice shall: 1. calculate the delta value between two consecutive values of a parameter; 2. declare the check successful when the delta value is less than or equal to the high threshold value and greater than or equal to the low threshold value.|C1|See definition of Delta Value Monitoring Procedure||||
6.12.3.3a|Parameter monitoring definition|The maximum number of parameter monitoring definitions that the parameter monitoring subservice can contemporaneously evaluate at any time shall be declared when specifying that subservice.|C2|This number is given by the sum of constants MON\_N\_PMON which must be set at framework instantiation time||||
b||The parameter monitoring subservice shall provide the capability to process several parameter monitoring definitions for the same on-board parameter.|C1|See definition of Parameter Monitoring Definition List||||
c||Whether the parameter monitoring subservice supports conditional checking of parameter monitoring definitions shall be declared when specifying that subservice.|C1|Conditional checking is supported for each monitored parameter (see definition of PMDL)||||
d||Whether the parameter monitoring subservice uses a single, subservice-specific monitoring interval for all parameter monitoring definitions or uses a definition-specific monitoring interval for each parameter monitoring definition shall be declared when specifying that subservice.|C1|To each parameter monitor, a dedicated monitoring period expressed as a multiple of MON\_PER is associated. See definition of parameter monitor attributes||||
e||If the parameter monitoring subservice uses a subservice-specific monitoring interval, that monitoring interval shall be declared when specifying that subservice.|C1|See previous requirement||||
f||Monitoring intervals shall be expressed in 'on-board parameter minimum sampling interval' units.|C1|See statement of compliance to previous two clauses||||
g||Each parameter monitoring definition shall contain: 1. the identifier of the parameter monitoring definition; 2. the identifier of the on-board parameter to monitor; 3. if the parameter monitoring subservice supports the conditional checking of parameter monitoring definitions, a check validity condition that yielding false prevents the check being performed; 4. if the parameter monitoring subservice uses definition-specific monitoring intervals, a monitoring interval; 5. a check definition.|C1|See definition of parameter monitor attributes in PMDL||||
h||Each check validity condition shall contain:1. the identifier of an on-board parameter to use as a validity parameter; 2. a bit-mask; 3. an expected value.|C1|See definition of parameter monitor attributes in PMDL||||
I||When computing the check validity condition, the parameter monitoring subservice shall: 1. perform a bitwise-and between the bit-mask and the sampled value of the validity parameter; 2. declare the condition true when the masked value equals the expected value.|C1|See definition of Monitoring Function Procedure||||
j||Each check definition shall contain: â€¦|C1|See definition of parameter monitor attributes and of Monitoring Function Procedures (but sub-clause (5) is unclear and compliance is TBD)||||
6.12.3.4a|Statuses|The parameter monitoring subservice shall maintain a status indicating whether the overall parameter monitoring function is enabled or disabled. |C1|The parameter monitoring function is disabled if the Monitoring Function Procedure is stopped. The status of the procedure is an observable data item.||||
b||When starting the parameter monitoring subservice, the overall parameter monitoring function status shall be set to 'enabled'.|C2|The starting of the Parameter Monitoring Procedure (and hence the enabling of the parameter monitoring function) is the responsibility of the host application (see use constraint S12-8)||||
c||For each parameter monitoring definition, the parameter monitoring subservice shall maintain a status indicating whether that parameter monitoring definition is enabled or disabled. |C1|A parameter monitoring is enabled if its Parameter Monitor Procedure is started.||||
d||For each parameter monitoring definition, the parameter monitoring subservice shall maintain a status indicating the established status of the checks performed on the monitored parameter. |C1|See definition of parameter monitor attributes in PMDL||||
6.12.3.5.1a|Enable the parameter monitoring function|The parameter monitoring subservice shall provide the capability to enable the parameter monitoring function.|C1|The PUS Framework supports command (12,15)||||
||Each request to enable the parameter monitoring function shall contain exactly one instruction to enable the parameter monitoring function.|C1|See definition of component MonEnbMonFncCmd||||
||For each valid instruction to enable the parameter monitoring function, the parameter monitoring subservice shall: 1. set the PMON function status to 'enabled'; 2. for each parameter monitoring definition that is enabled: 3 (a) set its PMON checking status to 'unchecked'; (b) reset the repetition counter; start the parameter monitoring process.|C1|See progress action of component MonEnbMonFncCmd||||
6.12.3.5.2a|Disable the parameter monitoring function|The parameter monitoring subservice shall provide the capability to disable the parameter monitoring function.|C1|The PUS Framework supports command (12,16)||||
b||Each request to disable the parameter monitoring function shall contain exactly one instruction to disable the parameter monitoring function.|C1|See definition of component MonDisMonFncCmd \||||
c||The parameter monitoring subservice shall reject any instruction to disable the parameter monitoring function if: 1. the on-board monitoring service includes a functional monitoring subservice whose functional monitoring function is enabled.|C1|See definition of Start Action of MonDisMonFncCmd component||||
d||For each request to disable the parameter monitoring function that is rejected, the parameter monitoring subservice shall generate a failed start of execution notification.|C1|See definition of Start Action of MonDisMonFncCmd component||||
e||For each valid instruction to disable the parameter monitoring function, the parameter monitoring subservice shall: 1. set the PMON function status to 'disabled'; 2. stop the parameter monitoring process.|C1|See definition of Progress Action of MonDisMonFncCmd component||||
6.12.3.6.1a|Enable parameter monitoring definitions|The parameter monitoring subservice shall provide the capability to enable parameter monitoring definitions.|C1|The PUS Extension of the CORDET Framework supports command (12,1)||||
b||Each request to enable parameter monitoring definitions shall contain one or more instructions to enable a parameter monitoring definition.|C1|See definition of component MonEnbParMonCmd||||
c||Each instruction to enable a parameter monitoring definition shall contain: 1. the identifier of the parameter monitoring definition.|C1|See definition of component MonEnbParMonCmd||||
d||The parameter monitoring subservice shall reject any instruction to enable a parameter monitoring definition if any of the following conditions occurs: 1. that instruction refers to a parameter monitoring definition identifier that is not in the PMON list; 2. that instruction refers to a parameter monitoring definition that is used by a protected functional monitoring definition.|C1|See definition of Start Action of command MonEnbParMonCmd||||
e||For each instruction to enable a parameter monitoring definition that it rejects, the parameter monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of command MonEnbParMonCmd||||
f||The parameter monitoring subservice shall process any valid instruction that is contained within a request to enable parameter monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Start Action of command MonEnbParMonCmd||||
g||For each valid instruction to enable a parameter monitoring definition, the parameter monitoring subservice shall: 1. reset the repetition counter of that parameter monitoring definition; 2. set the PMON status of that parameter monitoring definition to 'enabled'.|C1|See definition of Progress Action of command MonEnbParMonCmd||||
6.12.3.6.2a|Disable parameter monitoring definitions|The parameter monitoring subservice shall provide the capability to disable parameter monitoring definitions.|C1|The PUS Extension of the CORDET Framework supports command (12,2)||||
b||Each request to disable parameter monitoring definitions shall contain one or more instructions to disable a parameter monitoring definition.|C1|See definition of component MonDisParMonCmd||||
c||Each instruction to disable a parameter monitoring definition shall contain: 1. the identifier of the parameter monitoring definition.|C1|See definition of component MonDisParMonCmd||||
d||The parameter monitoring subservice shall reject any instruction to disable a parameter monitoring definition if any of the following conditions occurs: 1. that instruction refers to a parameter monitoring definition identifier that is not in the PMON list; 2. that instruction refers to a parameter monitoring definition that is used by a protected functional monitoring definition.|C1|See definition of Start Action of command MonDisParMonCmd||||
e||For each instruction to disable a parameter monitoring definition that it rejects, the parameter monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of command MonDisParMonCmd||||
f||The parameter monitoring subservice shall process any valid instruction that is contained within a request to disable parameter monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Start Action of command MonDisParMonCmd||||
g||For each valid instruction to disable a parameter monitoring definition, the parameter monitoring subservice shall: 1. set the PMON status of the parameter monitoring definition to 'disabled'; 2. set the PMON checking status of the parameter monitoring definition to 'unchecked'.|C1|See definition of Progress Action of command MonDisParMonCmd||||
6.12.3.6.3a|Parameter monitoring process|If the PMON function status is 'disabled', the parameter monitoring subservice shall not perform the parameter monitoring process for any parameter monitoring definitions.|C1|If the parameter monitoring function is disabled, the Monitoring Function Procedure is in the stopped state and it therefore does not execute any action||||
b||If the PMON status of a parameter monitoring definition is disabled, the parameter monitoring subservice shall not perform the parameter monitoring process for that definition.|C1|See definition of Monitoring Function Procedure||||
c||When performing the parameter monitoring process for a parameter monitoring definition, at the end of the monitoring interval, the parameter monitoring subservice shall, in sequence: 1. if the subservice supports the conditional checking of parameter monitoring definitions, compute the check validity condition; 2. if the computed check validity condition yields false: 3. (a) set the PMON checking status to 'invalid'; (b) reset the repetition counter of that parameter monitoring definition; if the subservice does not support the conditional checking of parameter monitoring definitions, or if the check validity condition yields true: (a) perform the check specified by the check definition, using a newly sampled value of the monitored parameter; (b) if the specified 'repetition number' of consecutive checks of the monitored parameter have all produced the same checking status output, establish a new PMON checking status;|C1|See definition of Monitoring Function Procedure||||
d||When a new PMON checking status is established, if that status differs from the previous PMON checking status, the parameter monitoring subservice shall: (a) record a check transition by adding that transition to the check transition list; (b) if an event definition is associated to that transition, raise the corresponding event.|C1|See definition of Monitoring Function Procedure||||
e||When a new PMON checking status is established for an expected-value-check, the parameter monitoring subservice shall set the PMON checking status to: 1. 'unexpected value' if the specified 'repetition number' of consecutive checks were declared unsuccessful; 2. 'expected value', if the specified 'repetition number' consecutive checks were declared successful.|C1|See definition of Monitoring Function Procedure and of Expected Value Monitor Procedure||||
f||When a new PMON checking status is established for a limit-check, the parameter monitoring subservice shall set the PMON checking status to: 1. 'above high limit', if the specified 'repetition number' of consecutive checks were declared unsuccessful and the parameter value in each check was greater than the high limit value; 2. 'below low limit', if the specified 'repetition number' of consecutive checks were declared unsuccessful and the parameter value in each check was less than the low limit value; 3. 'within limits', if the specified 'repetition number' of consecutive checks were declared successful.|C1|See definition of Monitoring Function Procedure and of Limit Check Monitor Procedure||||
g||When a new PMON checking status is established for a delta-check, the parameter monitoring subservice shall set the PMON checking status to: 1. 'above high threshold', if the specified 'repetition number' of consecutive checks were declared unsuccessful and the delta value in each check was greater than the high threshold value; 2. 'below low threshold', if the specified 'repetition number' of consecutive checks were declared unsuccessful and the delta value in each check was less than the low threshold value; 3. 'within thresholds', if the specified 'repet|C1|See definition of Monitoring Function Procedure and of Delta Value Monitor Procedure||||
6.12.3.7a|Reporting the check transitions|The parameter monitoring subservice shall provide the capability to report the contents of the check transition list.|C1|The PUS Extension of the CORDET Framework supports the (12,12) report||||
b||When reporting the contents of the check transition list, the parameter monitoring subservice shall: 1. for each check transition in the check transition list, generate a check transition notification containing: (a) the identifier of the parameter monitoring definition for which the check transition is recorded; (b) the identifier of the monitored parameter; (c) the check type; (d) for an expected-value-check, the expected-value-check mask; (e) the parameter value that has caused the transition; (f) the limit crossed; (g) the PMON checking status before the transition; (h) the PMON checking status resulting from the transition; (i) the transition time; 2. generate a single check transition report containing all the generated check transition notifications; 3. remove all the reported check transitions from the check transition list.|C1|See definition of MonChkTransRep||||
c||The maximum number of transitions required for issuing a check transition report shall be declared when specifying the parameter monitoring subservice.|C1|This is the same as the maximum size of the Check Transition List (CTL). This is defined when the service is instantiated.||||
d||The parameter monitoring subservice shall report the contents of the check transition list whenever one of the following condition occurs: 1. the maximum number of transitions required for issuing a check transition report is reached; 2. at the maximum transition reporting delay after the occurrence of the first check transition recorded in the check transition list.|C1|See definition of Ready Check of MonChkTransRep||||
e||The maximum transition reporting delay shall be expressed in 'on-board parameter minimum sampling interval' units.|C1|See definition of constants associated to service 12. The value of the constant is defined when the service is instantiated.||||
f||The default maximum transition reporting delay shall be declared when specifying the parameter monitoring subservice.|C1|See definition of constants associated to service 12. The value of the constant is defined when the service is instantiated.||||
6.12.3.8a|Change the maximum transition reporting delay|The parameter monitoring subservice capability to change the maximum transition reporting delay shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,3) report||||
||Each request to change the maximum transition reporting delay shall contain exactly one instruction to change the maximum transition reporting delay |C1|See definition of component MonChgTransDelCmd||||
||Each instruction to change the maximum transition reporting delay shall contain: 1. the maximum transition reporting delay.|C1|See definition of component MonChgTransDelCmd||||
||For each valid instruction to change the maximum transition reporting delay, the parameter monitoring subservice shall: 1. set the maximum transition reporting delay to the value specified in that instruction.|C1|See progress action of MonChgTransDelCmd command||||
6.12.3.9.1a|Add parameter monitoring definitions|The parameter monitoring subservice capability to add parameter monitoring definitions shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,5) command (but the optional Monitoring Interval field is not supported)||||
b||If the capability to add parameter monitoring definitions is provided by the parameter monitoring subservice, that subservice shall provide at least one of the following capabilities: 1. the capability to delete all parameter monitoring definitions specified in clause 6.12.3.9.2; 2. the capability to delete parameter monitoring definitions specified in clause 6.12.3.9.3.|C1|Both capabilities are supported by the PUS Extension of the CORDET Framework.||||
c||Each request to add parameter monitoring definitions shall contain one or more instructions to add a parameter monitoring definition.|C1|See definition of component MonAddParMonCmd||||
d||Each instruction to add a parameter monitoring definition shall contain: 1. the contents of the parameter monitoring definition.|C1|See definition of component MonAddParMonCmd||||
e||The parameter monitoring subservice shall reject any instruction to add a parameter monitoring definition if any of the following conditions occurs: 1. that instruction cannot be added since the PMON list is full; 2. that instruction refers to a parameter monitoring definition identifier that is already in the PMON list; 3. that instruction refers to a parameter to monitor that is not accessible; 4. that instruction refers to a validity parameter that is not accessible; 5. that instruction refers to a limit check for which the high limit is lower than the low limit; 6. that instruction refers to a delta check for which the high threshold is lower than the low threshold.|C1|See definition of Start Action of MonAddParMonCmd but note that: (a) in additional to the rejection conditions stated in this clause, additional ones are defined by the PUS Extension; and (b) conditions 3 and 4 are always satisfied because the parameter to monitor and the validity parameters are data pool items and data pool items are always accessible.||||
f||For each instruction to add a parameter monitoring definition that it rejects, the parameter monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of MonAddParMonCmd||||
g||The parameter monitoring subservice shall process any valid instruction that is contained within a request to add parameter monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Start Action of MonAddParMonCmd||||
h||For each valid instruction to add a parameter monitoring definition, the parameter monitoring subservice shall: 1. add a new parameter monitoring definition to the PMON list, using data from that instruction; 2. set the PMON checking status of the new parameter monitoring definition to 'unchecked'; 3. set the PMON status of the new parameter monitoring definition to 'disabled'.|C1|See definition of Progress Action of MonAddParMonCmd||||
6.12.3.9.2a|Delete all parameter monitoring definitions|The parameter monitoring subservice capability to delete all parameter monitoring definitions shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,4) command||||
b||Each request to delete all parameter monitoring definitions shall contain exactly one instruction to delete all parameter monitoring definitions.|C1|See definition of component MonDelAllParMonCmd||||
c||The parameter monitoring subservice shall reject any request to delete all parameter monitoring definitions if any of the following conditions occurs: 1. the PMON list contains one or more parameter monitoring definitions that are used by the functional monitoring subservice; 2. the PMON function status is 'enabled'.|C1|See definition of Start Action of MonDelAllParMonCmd command||||
d||For each request to delete all parameter monitoring definitions that is rejected, the parameter monitoring subservice shall generate a failed start of execution notification.|C1|See definition of Start Action of MonDelAllParMonCmd command||||
e||For each valid instruction to delete all parameter monitoring definitions, the parameter monitoring subservice shall: 1. delete all entries in the PMON list; 2. delete all entries in the check transition list.|C1|See definition of Progress Action of MonDelAllParMonCmd command||||
6.12.3.9.3a|Delete parameter monitoring definitions|The parameter monitoring subservice capability to delete parameter monitoring definitions shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,6) command||||
b||Each request to delete parameter monitoring definitions shall contain one or more instructions to delete a parameter monitoring definition.|C1|See definition of component MonDelParMonCmd||||
c||Each instruction to delete a parameter monitoring definition shall contain: 1. the identifier of the parameter monitoring definition.|C1|See definition of component MonDelParMonCmd||||
d||The parameter monitoring subservice shall reject any instruction to delete a parameter monitoring definition if any of the following conditions occurs: 1. that instruction refers to a parameter monitoring definition identifier that is not in the PMON list; 2. that instruction refers to a parameter monitoring definition whose PMON status is 'enabled'; 3. that instruction refers to a parameter monitoring definition that is used by a functional monitoring definition.|C1|See definition of Start Action of MonDelParMonCmd command||||
e||For each instruction to delete a parameter monitoring definition that it rejects, the parameter monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of MonDelParMonCmd command||||
f||The parameter monitoring subservice shall process any valid instruction that is contained within a request to delete parameter monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Start Action of MonDelParMonCmd command||||
g||For each valid instruction to delete a parameter monitoring definition, the parameter monitoring subservice shall: 1. remove the parameter monitoring definition that is referred to by that instruction from the PMON list.|C1|See definition of Progress Action of MonDelParMonCmd command||||
6.12.3.9.4a|Modify parameter monitoring definitions|The parameter monitoring subservice capability to modify parameter monitoring definitions shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,7) command||||
b||Each request to modify parameter monitoring definitions shall contain one or more instructions to modify a parameter monitoring definition.|C1|See definition of MonModParMonCmd command||||
c||Each instruction to modify a parameter monitoring definition shall contain: 1. the identifier of the parameter monitoring definition; the identifier of the monitored parameter used by that parameter monitoring definition; 3. the means to modify: (a) the repetition number; (b) for a limit-check, its low limit, its high limit and the event definition identifier of each associated event; (c) for an expected-value-check, its expected-value-check mask, its expected value and the event definition identifier of its associated event; (d) for a delta-check, its low delta threshold, its high delta threshold and the event definition identifier of each associated event.|C1|See definition of MonModParMonCmd command||||
d||The parameter monitoring subservice shall reject any instruction to modify a parameter monitoring definition if any of the following conditions occurs: 1. that instruction refers to a parameter monitoring definition identifier that is not in the PMON list; 2. that instruction refers to a monitored parameter that is not the one used in that parameter monitoring definition; 3. that instruction refers to a limit check for which the high limit is lower than the low limit; 4. that instruction refers to a delta check for which the high threshold is lower than the low threshold; 5. that instruction refers to a parameter monitoring definition that is used by a protected functional monitoring definition.|C1|See definition of Start Action of MonModParMonCmd command||||
e||For each instruction to modify a parameter monitoring definition that it rejects, the parameter monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of MonModParMonCmd command||||
f||The parameter monitoring subservice shall process any valid instruction that is contained within a request to modify parameter monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Progress Action of MonModParMonCmd command||||
||For each valid instruction to modify a parameter monitoring definition, the parameter monitoring subservice shall: 1. modify the parameter monitoring definition that is referred to by that instruction, using data from that instruction; 2. set the PMON checking status of the modified parameter monitoring definition to unchecked; 3. reset the repetition counter of that parameter monitoring definition.|C1|See definition of Progress Action of MonModParMonCmd command||||
6.12.3.10a|Report parameter monitoring definitions|The parameter monitoring subservice capability to report parameter monitoring definitions shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports both the (12,8) command and the (12,9) report||||
b||Each request to report parameter monitoring definitions shall contain: 1. one or more instructions to report a parameter monitoring definition, or 2. exactly one instruction to report all parameter monitoring definitions.|C1|See definition of MonRepParMonCmd command and MonRepParMonRep report||||
c||Each request to report parameter monitoring definitions shall contain: 1. one or more instructions to report a parameter monitoring definition, or 2. exactly one instruction to report all parameter monitoring definitions.|C1|See definition of MonRepParMonCmd command ||||
d||Each instruction to report a parameter monitoring definition shall contain: 1. the identifier of the parameter monitoring definition.|C1|See definition of MonRepParMonCmd command ||||
e||The parameter monitoring subservice shall reject any instruction to report a parameter monitoring definition if: 1. that instruction refers to a parameter monitoring definition identifier that is not in the PMON list.|C1|See definition of Start Action of MonRepParMonCmd command ||||
f||For each instruction to report a parameter monitoring definition that it rejects, the parameter monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of MonRepParMonCmd command ||||
g||The parameter monitoring subservice shall process any valid instruction that is contained within a request to report parameter monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Progress Action of MonRepParMonCmd command ||||
h||For each valid instruction to report a parameter monitoring definition, the parameter monitoring subservice shall generate a single parameter monitoring definition notification that includes: 1. the parameter monitoring definition that is referred to by that instruction; 2. the PMON status of that parameter monitoring definition.|C1|See definition of Progress Action of MonRepParMonCmd command and MonRepParMonRep report||||
I||For each valid instruction to report all parameter monitoring definitions, the parameter monitoring subservice shall generate, for each parameter monitoring definition maintained by that subservice, a single parameter monitoring definition notification.|C1|See definition of MonRepParMonCmd command and MonRepParMonRep report||||
j||For each valid request to report parameter monitoring definitions, the parameter monitoring subservice shall generate a single parameter monitoring definition report that contains: 1. if changing the maximum transition reporting delay is supported, the current value of that delay; 2. all related parameter monitoring definition notifications.|C1|See definition of MonRepParMonCmd command and MonRepParMonRep report||||
6.12.3.11a|Report the status of each parameter monitoring Definition|The parameter monitoring subservice capability to report the status of each parameter monitoring definition shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports both the (12,14) command and the (12,15) report||||
b||Each request to report the status of each parameter monitoring definition shall contain exactly one instruction to report the status of each parameter monitoring definition.|C1|See definition of MonRepParMonCmd command and MonRepParMonRep report||||
c||For each valid instruction to report the status of each parameter monitoring definition, the parameter monitoring subservice shall: 1. generate, for each parameter monitoring definition in the PMON list, a single parameter monitoring definition status notification that includes: (a) the identifier of the parameter monitoring definition; (b) its PMON status.|C1|See definition of MonRepParMonCmd command and MonRepParMonRep report||||
d||For each valid request to report the status of each parameter monitoring definition, the parameter monitoring subservice shall generate a single parameter monitoring definition status report that includes all related parameter monitoring definition status notifications.|C1|See definition of MonRepParMonCmd command and MonRepParMonRep report||||
6.12.3.12a|Report the out-of-limits|The parameter monitoring subservice capability to report the out-of-limits shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports both the (12,10) command and the (12,11) report||||
b||Each request to report the out-of-limits shall contain exactly one instruction to report the out-of-limits.|C1|See definition of MonRepOutOfLimitsCmd command and MonRepOutOfLimitsRep report||||
c||For an expected-value-check, only the following transitions shall be reported in the out-of-limits report: 1. unchecked to unexpected value; 2. invalid to unexpected value; 3. expected value to unexpected value.|C1|The Start Action of the MonRepOutOfLimitsCmd command retrieves from the CTL all the transactions which have resulted in a violation. These transactions are then reported by the MonRepOutOfLimitsRep report||||
d||For a limit-check, only the following transitions shall be reported in the out-of-limits report: 1. unchecked to below low limit; 2. unchecked to above high limit; 3. invalid to below low limit; 4. invalid to above high limit; 5. within limits to below low limit; 6. within limits to above high limit; 7. below low limit to above high limit; 8. above high limit to below low limit.|C1|The Start Action of the MonRepOutOfLimitsCmd command retrieves from the CTL all the transactions which have resulted in a violation. These transactions are then reported by the MonRepOutOfLimitsRep report||||
e||For a delta-check, only the following transitions shall be reported in the out-of-limits report: 1. unchecked to below low threshold; 2. unchecked to above high threshold; 3. invalid to below low threshold; 4. invalid to above high threshold; 5. within threshold to below high threshold; 6. within threshold to above high threshold; 7. below low threshold to above high threshold; 8. above high threshold to below low threshold.|C1|The Start Action of the MonRepOutOfLimitsCmd command retrieves from the CTL all the transactions which have resulted in a violation. These transactions are then reported by the MonRepOutOfLimitsRep report||||
f||For each valid instruction to report the out-of-limits, the parameter monitoring subservice shall generate: 1. for each check transition to report, a single out-of-limit notification that includes: (a) the identifier of the parameter monitoring definition for which the check transition is recorded; (b) the identifier of the monitored parameter; (c) the check type; (d) for an expected-value-check, the expected-value-check mask; (e) the parameter value that has caused the transition; (f) the limit crossed; (g) the PMON checking status before the transition; (h) the PMON checking status resulting from the transition; (i) the transition time.|C1|See definition of MonRepOutOfLimitsCmd command and MonRepOutOfLimitsRep report||||
g||For each valid request to report the out-of-limits, the parameter monitoring subservice shall generate a single out-of-limits report that includes all related out-of-limit notifications.|C1|See definition of MonRepOutOfLimitsCmd command and MonRepOutOfLimitsRep report||||
6.12.3.13|Subservice observables|The following observables shall be defined for the parameter monitoring subservice: 1. the number of remaining available entries in the parameter monitoring definition list; 2. the number of enabled parameter monitoring definitions; 3. the PMON function status.|C1|See definition of observable Data Items associated to service 12 in [PX-SP]||||
6.12.4.1.1a| Parameter monitoring definition|The functional monitoring subservice shall be able to observe, at any time, the PMON checking status of each parameter monitoring definition of the parameter monitoring subservice of the parent on-board Monitoring service.|C1|Capability is implicitly provided by the specification of the commands and reports which implement the functional monitoring function||||
6.12.4.1.2a|General|The maximum number of functional monitoring definitions that the functional monitoring subservice can contemporaneously evaluate at any time shall be declared when specifying that subservice.|C1|See definition of constants associated to service 12. The value of the constant is defined when the service is instantiated.||||
b||The maximum number of parameter monitoring definitions that a functional monitoring definition can refer to shall be declared when specifying the functional monitoring subservice.|C1|See definition of constants associated to service 12. The value of the constant is defined when the service is instantiated.||||
c||Whether the functional monitoring subservice supports conditional checking of functional monitoring definitions shall be declared when specifying that subservice.|C1|Conditional checking is supported. ||||
d||Whether the functional monitoring subservice supports specifying, for each functional monitoring definition, the minimum number of contemporaneously violated parameter monitoring definitions that establishes a functional monitoring checking failure shall be declared when specifying that subservice.|C1|Definition of a minimum failing number is supported for each functional monitor||||
e||If the functional monitoring subservice does not support specifying, for each functional monitoring definition, the minimum PMON failing number, the subservice shall use a value of 1 as the minimum PMON failing number for all functional monitoring definitions.|n.a.|See previous requirement||||
f||Each functional monitoring definition shall contain: 1. its identifier; 2. if the functional monitoring subservice supports the conditional checking of functional monitoring definitions, a check validity condition that yielding false prevents the check being performed; 3. the event definition identifier of the event to raise; 4. if the subservice supports specifying the minimum PMON failing number, a minimum PMON failing number; 5. a set of one or more parameter monitoring definition identifiers.|C1|See definition of attributes of a functional monitor in the Functional Monitoring Definition List (FMDL) in [PX-SP]||||
6.12.4.1.3a|Statuses|The functional monitoring subservice shall maintain a status indicating whether the overall functional monitoring function is enabled or disabled.|C1|See definition of observables associated to service 12. ||||
b||For each functional monitoring definition, the functional monitoring subservice shall maintain a status indicating whether that functional monitoring definition is enabled or disabled.|C1|See definition of attributes of a functional monitor in the Functional Monitoring Definition List (FMDL) in [PX-SP]||||
c||For each functional monitoring definition, the functional monitoring subservice shall maintain a status indicating the result of the check performed.|C1|See definition of attributes of a functional monitor in the Functional Monitoring Definition List (FMDL) in [PX-SP]||||
d||If the functional monitoring subservice supports the capability for protecting functional monitoring definitions, the functional monitoring subservice shall maintain, for each functional monitoring definition, a status indicating whether that functional monitoring definition is protected or unprotected.|C1|See definition of attributes of a functional monitor in the Functional Monitoring Definition List (FMDL) in [PX-SP]||||
6.12.4.4.1a|Enable the functional monitoring function|The functional monitoring subservice shall provide the capability to enable the functional monitoring function.|C1|The PUS Extension of the CORDET Framework supports the (12,17) command||||
b||Each request to enable the functional monitoring function shall contain exactly one instruction to enable the functional monitoring function.|C1|See definition of MonEnbFuncMonCmd command||||
c||The functional monitoring subservice shall reject any request to enable the functional monitoring function if: 1. the parameter monitoring function of the associated parameter monitoring subservice is disabled.|C1|See definition of Start Action of MonEnbFuncMonCmd command||||
d||For each request to enable the functional monitoring function that is rejected, the functional monitoring subservice shall generate a failed start of execution notification.|C1|See definition of Start Action of MonEnbFuncMonCmd command||||
e||For each valid instruction to enable the functional monitoring function, the functional monitoring subservice shall: 1. set the FMON function status to enabled; 2. for each functional monitoring definition that is enabled: (a) 3. set its FMON checking status to unchecked; start immediately the monitoring of the enabled functional monitoring definitions.|C1|See definition of Progress Action of MonEnbFuncMonCmd command||||
6.12.4.4.2a|Disable the functional monitoring function|The functional monitoring subservice shall provide the capability to disable the functional monitoring function.|C1|The PUS Extension of the CORDET Framework supports the (12,18) command||||
b||Each request to disable the functional monitoring function shall contain exactly one instruction to disable the functional monitoring function.|C1|See definition of MonDisFuncMonCmd command||||
c||For each valid instruction to disable the functional monitoring function, the functional monitoring subservice shall: 1. set the FMON function status to disabled. 2. stop immediately the monitoring of the functional monitoring definitions.|C1|See definition of Progress Action of MonDisFuncMonCmd command||||
6.12.4.5.1|Monitoring transitions|For each functional monitoring definition, whenever a new PMON checking status has been established for one of its parameter monitoring definitions, the functional monitoring subservice shall perform the following: 1. If the FMON function status is enabled and the FMON status is enabled and the current FMON checking status is not failed: (a) the check validity condition, if any, is computed; (b) If the computed check validity condition yields false, the FMON checking status is set to invalid. 2. If the FMON function status is enabled, the FMON status is enabled and the current FMON checking status is neither failed nor invalid: (a) check if the number of related parameter monitoring definitions that are contemporaneously in violation equals or exceeds the minimum PMON failing number; (b) if the check yields true, the FMON checking status is set to failed and the associated event is raised; (c) if the check yields false, the FMON checking status is set to running.|C1|See definition of Functional Monitor Notification Procedure in [PX-SP]||||
6.12.4.5.2a|Enable functional monitoring definitions|The functional monitoring subservice shall provide the capability to enable functional monitoring definitions.|C1|The PUS Extension of the CORDET Framework supports the (12,19) command||||
b||Each request to enable functional monitoring definitions shall contain one or more instructions to enable a functional monitoring definition.|C1|See definition of MonEnbFuncMonDefCmd command||||
c||Each instruction to enable a functional monitoring definition shall contain: 1. the identifier of the functional monitoring definition.|C1|See definition of MonEnbFuncMonDefCmd command||||
d||The functional monitoring subservice shall reject any instruction to enable a functional monitoring definition if: 1. that instruction refers to a functional monitoring definition identifier that is not in the FMON list.|C1|See definition of Start Action of MonEnbFuncMonDefCmd command||||
e||For each instruction to enable a functional monitoring definition that it rejects, the functional monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of MonEnbFuncMonDefCmd command||||
f||The functional monitoring subservice shall process any valid instruction that is contained within a request to enable functional monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Progress Action of MonEnbFuncMonDefCmd command||||
g||For each valid instruction to enable a functional monitoring definition, the functional monitoring subservice shall: 1. set the FMON status of the functional monitoring definition to enabled|C1|See definition of Progress Action of MonEnbFuncMonDefCmd command||||
6.12.4.5.3a|Disable functional monitoring definitions|The functional monitoring subservice shall provide the capability to disable functional monitoring definitions.|C1|The PUS Extension of the CORDET Framework supports the (12,20) command||||
b||Each request to disable functional monitoring definitions shall contain one or more instructions to disable a functional monitoring definition.|C1|See definition of MonDisFuncMonDefCmd command||||
c||Each instruction to disable a functional monitoring definition shall contain: 1. the identifier of the functional monitoring definition.|C1|See definition of MonDisFuncMonDefCmd command||||
d||The functional monitoring subservice shall reject any instruction to disable a functional monitoring definition if: 1. that instruction refers to a functional monitoring definition identifier that is not in the FMON list.|C1|See definition of Start Action of MonDisFuncMonDefCmd command||||
e||For each instruction to disable a functional monitoring definition that it rejects, the functional monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of MonDisFuncMonDefCmd command||||
f||The functional monitoring subservice shall process any valid instruction that is contained within a request to disable functional monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Progress Action of MonDisFuncMonDefCmd command||||
g||For each valid instruction to disable a functional monitoring definition, the functional monitoring subservice shall: 1. set the FMON status of the functional monitoring definition to disabled; 2. set the FMON checking status of the functional monitoring definition to unchecked.|C1|See definition of Progress Action of MonDisFuncMonDefCmd command||||
6.12.4.6.1a|Protect functional monitoring definitions|The functional monitoring subservice capability to protect functional monitoring definitions shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,21) command||||
b||Each request to protect functional monitoring definitions shall contain one or more instructions to protect a functional monitoring definition.|C1|See definition of MonProtFuncMonDefCmd command||||
c||Each instruction to protect a functional monitoring definition shall contain: 1. the identifier of the functional monitoring definition.|C1|See definition of MonProtFuncMonDefCmd command||||
d||The functional monitoring subservice shall reject any instruction to protect a functional monitoring definition if: 1. that instruction refers to a functional monitoring definition identifier that is not in the FMON list.|C1|See definition of Start Action of MonProtFuncMonDefCmd command||||
e||For each instruction to protect a functional monitoring definition that it rejects, the functional monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of MonProtFuncMonDefCmd command||||
f||The functional monitoring subservice shall process any valid instruction that is contained within a request to protect functional monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Progress Action of MonProtFuncMonDefCmd command||||
g||For each valid instruction to protect a functional monitoring definition, the functional monitoring subservice shall: 1. set the FMON protection status of the functional monitoring definition to protected.|C1|See definition of Progress Action of MonProtFuncMonDefCmd command||||
6.12.4.6.2a|Unprotect functional monitoring definitions|The functional monitoring subservice capability to unprotect functional monitoring definitions shall be provided if the capability to protect functional monitoring definitions is provided by that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,22) command||||
b||Each request to unprotect functional monitoring definitions shall contain one or more instructions to unprotect a functional monitoring definition.|C1|See definition of MonUnprotFuncMonDefCmd command||||
c||Each instruction to unprotect a functional monitoring definition shall contain: 1. the identifier of the functional monitoring definition.|C1|See definition of MonUnprotFuncMonDefCmd command||||
d||The functional monitoring subservice shall reject any instruction to unprotect a functional monitoring definition if: 1. that instruction refers to a functional monitoring definition identifier that is not in the FMON list.|C1|See definition of Start Action of MonUnprotFuncMonDefCmd command||||
e||For each instruction to unprotect a functional monitoring definition that it rejects, the functional monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of MonUnprotFuncMonDefCmd command||||
f||The functional monitoring subservice shall process any valid instruction that is contained within a request to unprotect functional monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Progress Action of MonUnprotFuncMonDefCmd command||||
g||For each valid instruction to unprotect a functional monitoring definition, the functional monitoring subservice shall: 1. set the FMON protection status of the functional monitoring definition to unprotected.|C1|See definition of Progress Action of MonUnprotFuncMonDefCmd command||||
6.12.4.7.1a|Add functional monitoring definitions|The functional monitoring subservice capability to add functional monitoring definitions shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,23) command||||
b||Each request to add functional monitoring definitions shall contain one or more instructions to add a functional monitoring definition.|C1|See definition of MonAddFuncMonDefCmd command||||
c||Each instruction to add a functional monitoring definition shall contain: 1. the contents of the functional monitoring definition.|C1|See definition of MonAddFuncMonDefCmd command||||
d||The functional monitoring subservice shall reject any request to add functional monitoring definitions if any of the following conditions occurs: 1. that request contains an instruction that refers to a functional monitoring definition identifier that is already in the FMON list; 2. that request contains more than one instruction for the same functional monitoring definition.|C1|See definition of Start Action of MonAddFuncMonDefCmd command||||
e||The functional monitoring subservice shall reject any instruction to add a functional monitoring definition if any of the following conditions occurs: 1. that instruction cannot be added since the FMON list is full; 2. that instruction refers to a parameter monitoring definition identifier that is not in the PMON list; 3. that instruction refers to a validity parameter that is not accessible.|C1|See definition of Start Action of MonAddFuncMonDefCmd command||||
f||For each request to add functional monitoring definitions that it rejects, the functional monitoring subservice shall generate the failed start of execution notification for that request.|C1|See definition of Start Action of MonAddFuncMonDefCmd command||||
g||For each instruction to add a functional monitoring definition that it rejects, the functional monitoring subservice shall generate the failed start of execution notification for that instruction.|C1|See definition of Start Action of MonAddFuncMonDefCmd command||||
h||The functional monitoring subservice shall process any valid instruction that is contained within a request to add functional monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Progress Action of MonAddFuncMonDefCmd command||||
I||For each valid instruction to add a functional monitoring definition, the functional monitoring subservice shall: 1. add a new functional monitoring definition to the FMON list, using data from that instruction; 2. set the FMON checking status of the new functional monitoring definition to unchecked; 3. set the FMON status of the new functional monitoring definition to disabled; 4. if the functional monitoring subservice supports the capability for protecting functional monitoring definitions, set the FMON protection status of the new functional monitoring definition to protected.|C1|See definition of Progress Action of MonAddFuncMonDefCmd command||||
6.12.4.7.2a|Delete functional monitoring definitions|The functional monitoring subservice shall provide the capability to delete functional monitoring definitions if the capability to add functional monitoring definitions is provided by that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,24) command||||
b||Each request to delete functional monitoring definitions shall contain one or more instructions to delete a functional monitoring definition.|C1|See definition of MonDelFuncMonDefCmd command||||
c||Each instruction to delete a functional monitoring definition shall contain: 1. the identifier of the functional monitoring definition.|C1|See definition of MonDelFuncMonDefCmd command||||
d||The functional monitoring subservice shall reject any instruction to delete a functional monitoring definition if any of the following conditions occurs: 1. that instruction refers to a functional monitoring definition identifier that is not in the FMON list; 2. that instruction refers to a functional monitoring definition whose FMON status is enabled; 3. that instruction refers to a functional monitoring definition whose FMON protection status is protected.|C1|See definition of Start Action of MonDelFuncMonDefCmd command||||
e||For each instruction to delete a functional monitoring definition that it rejects, the functional monitoring subservice shall generate the failed start of execution notification for that instruction. |C1|See definition of Start Action of MonDelFuncMonDefCmd command||||
f||The functional monitoring subservice shall process any valid instruction that is contained within a request to delete functional monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Progress Action of MonDelFuncMonDefCmd command||||
g||For each valid instruction to delete a functional monitoring definition, the functional monitoring subservice shall: 1. remove the functional monitoring definition that is referred to by that instruction from the FMON list.|C1|See definition of Progress Action of MonDelFuncMonDefCmd command||||
6.12.4.8a|Report functional monitoring definitions|The functional monitoring subservice capability to report functional monitoring definitions shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,25) command and the (12,26) report||||
b||Each request to report functional monitoring definitions shall contain: 1. one or more instructions to report a functional monitoring definition, or 2. exactly one instruction to report all functional monitoring definitions.|C1|See definition of MonRepFuncMonDefCmd command||||
c||Each instruction to report a functional monitoring definition shall contain: 1. the identifier of the functional monitoring definition.|C1|See definition of MonRepFuncMonDefCmd command||||
d||The functional monitoring subservice shall reject any instruction to report a functional monitoring definition if: 1. that instruction refers to a functional monitoring definition identifier that is not in the FMON list.|C1|See definition of Start Action of MonRepFuncMonDefCmd command||||
e||For each instruction to report a functional monitoring definition that it rejects, the functional monitoring subservice shall generate the failed start of execution notification for that instruction|C1|See definition of Start Action of MonRepFuncMonDefCmd command||||
f||The functional monitoring subservice shall process any valid instruction that is contained within a request to report functional monitoring definitions regardless of the presence of faulty instructions.|C1|See definition of Progress Action of MonRepFuncMonDefCmd command||||
g||For each valid instruction to report a functional monitoring definition, the functional monitoring subservice shall 1. generate a single functional monitoring definition notification that includes: (a) the content of the functional monitoring definition that is referred to by that instruction; (b) if the functional monitoring subservice supports the capability for protecting functional monitoring definitions, the FMON protection status of that functional monitoring definition; (c) the FMON status of that functional monitoring definition.|C1|See definition of Progress Action of MonRepFuncMonDefCmd command||||
h||For each valid instruction to report all functional monitoring definitions, the functional monitoring subservice shall: 1. for each functional monitoring definition maintained by that subservice, generate a single functional monitoring definition notification that includes: (a) the contents of that functional monitoring definition; (b) if the functional monitoring subservice supports the capability for protecting functional monitoring definitions, the FMON protection status of that functional monitoring definition; (c) the FMON status of that functional monitoring definition.|C1|See definition of Progress Action of MonRepFuncMonDefCmd command||||
I||For each valid request to report functional monitoring definitions, the functional monitoring subservice shall generate a single functional monitoring definition report that contains all related functional monitoring definition notifications.|C1|See definition of Progress Action of MonRepFuncMonDefCmd command and of MonRepFuncMonDefRep report||||
6.12.4.9a|Report the status of each functional monitoring Definition|The functional monitoring subservice capability to report the status of each functional monitoring definition shall be declared when specifying that subservice.|C1|The PUS Extension of the CORDET Framework supports the (12,26) report||||
b||Each request to report the status of each functional monitoring definition shall contain exactly one instruction to report the status of each functional monitoring definition.|C1|See definition of MonRepFuncMonDefRep report||||
c||For each valid instruction to report the status of each functional monitoring definition, the functional monitoring subservice shall: 1. generate, for each functional monitoring definition in the FMON list, a single functional monitoring definition status notification that includes: (a) the identifier of that functional monitoring definition; (b) if the functional monitoring subservice supports the capability for protecting functional monitoring definitions, its FMON protection status; (c) its FMON status; (d) its FMON checking status.|C1|See definition of MonRepFuncMonDefRep report||||
d||For each valid request to report the status of each functional monitoring definition, the functional monitoring subservice shall generate a single functional monitoring definition status report that includes all related functional monitoring definition status notifications.|C1|See definition of Progress Action of MonRepFuncMonDefCmd command and of MonRepFuncMonDefRep report||||
6.12.4.10|Subservice observables|The following observables shall be defined for the functional monitoring subservice: 1. the number of remaining available entries in the functional monitoring definition list; 2. the number of enabled functional monitoring definitions; 3. the FMON function status.|C1|See definition of service 12 observables in [PX-SP]||||
6.13|Large Packet Transfer|Definition of service 13||||||
6.13.2.1.1|Subservice|Each large packet transfer service shall contain at least one of: 1. the large packet downlink subservice; 2. the large packet uplink subservice.|C1|The PUS Extension of the CORDET Framework supports both sub-services||||
6.13.2.1.2|Large packet downlink subservice|Each large packet transfer service shall contain at most one large packet downlink subservice.|C1|An application instantiated from the CORDET Framework can only provide one instance of a service of a given type and of its sub-services||||
6.13.2.1.3|Large packet uplink subservice|Each large packet transfer service shall contain at most one large packet uplink subservice.|C1|An application instantiated from the CORDET Framework can only provide one instance of a service of a given type and of its sub-services||||
6.13..2.2a|Application process|Each large packet transfer subservice provider shall be hosted by exactly one application process. \newline NOTE: This implies that when both the large packet downlink subservice and the large packet uplink subservice are supported, the sending entity of the downlink subservice and the receiving entity of the uplink subservice are both hosted by that same on-board application process.|C2|In the CORDET Framework, the allocation of sub-services to application processes is done during the framework instantiation process when the application developers define the groups (see section 4.2 of [PX-SP]||||
b||Each application process shall host at most one large packet transfer subservice provider.|C1|The PUS Extension of the CORDET Framework supports one large packet transfer service per application||||
6.13.3.1a|Configuration of large packet downlink subservice|The maximum number of large packets that can be downlinked concurrently shall be declared when specifying the large packet downlink subservice.|C2|Each down- or up-transfer locks a Large Packet Transfer Buffer for the duration of the transfer. Hence, the maximum number of simultaneously active up- and down-transfers is determined by the number Large Packet Transfer Buffers available in the host application. This is an application constant set during the framework instantiation process (see definition of Constants for Service 13 in [PX-SP]).||||
b||The part size used by the large packet downlink subservice to decompose large packets shall be declared when specifying that subservice.|C2|The part size is one of the parameters defined by the PUS Extension for service 13 (see definition of Parameters for Service 13 in [PX-SP])||||
c||The maximum time allocated to the receiving entity for receiving a subsequent downlink part report after the reception of the previous one shall be declared when specifying the large packet downlink subservice.|n.a.|The PUS Extension of the CORDET Framework does not cover the reception of down-link transfers.||||
6.13.3.2|Resources|The resources allocated to the sending entity of the large packet downlink subservice to process large packets shall be declared when specifying the spacecraft architecture and its operations.|C2|The only framework resources used by the large packet transfer service are the memory used to create the up- and down-transfer packets and the resources for the Large Packet Transfer Buffers. The former resources are allocated within the factory components which create the components encapsulating the packets and are therefore declared when the factories are instantiated and when their adaptation points FAC-1 and FAC-2 are closed. The latter resources are declared when the values of the service 13 constants are defined at application instantiation time. Bandwidth resources for the down- and up-transfers are provided by the middleware and they are therefore declared when the InStream and OutStream components are defined during the instantiation process.||||
6.13.3.3.1a|Downlink Process|The sending entity of the large packet downlink subservice shall have the capability to process each large packet that it receives. \newline NOTE: This Standard assumes that on-board, the large packets are not duplicated. The synchronization between the source of the large packets and the large packet downlink subservice is beyond the scope of this Standard.|C1|The PUS Extension uses Large Packet Transfer Buffers (LPTBs) to hold the data corresponding to one single down- or up-transfer. There is therefore no duplication of packet data.||||
b||For each large packet that it processes, the sending entity of the large packet downlink subservice shall: 1. assign a unique large message transaction identifier to that large packet; 2. split the large packet into parts; 3. associate to each part, a unique part sequence number; 4. encapsulate each part into a single downlink part report.|C1|These capability are implemented by the LPT State Machine of the PUS Extension.||||
c||Each part report shall contain exactly one part notification made of: (a) an identifier of whether the part report contains the First part, an Intermediate part or the Last part of the large packet; (b) the large message transaction identifier; (c) the part sequence number; (d) the part itself.|C1|See definition of components LptDownFirstRep, LptDownInterRep and LptDownLastRep||||
d||The destination of the part reports generated by the large packet downlink subservice shall be declared when specifying the space to ground architecture.|C2|For each Large Packet Transfer Buffer, a destination is defined as a parameter of the service 13 definition in the PUS Extension (see definition of Parameters for Service 13 in [PX-SP]).||||
e||The sending entity of the large packet downlink subservice shall generate the part reports related to each large packet, in increasing order of the part sequence number and at the highest frequency supported under the prevailing operation constraints.|C2|The LPT State Machine which manages a down-link transfer hands over a packet to the middleware every time it is executed. The frequency of execution of the LPT State Machine is decided by the host application.||||
6.13.3.3.2|Accepting part reports and reconstructing large packets||n.a.|The PUS Extension of the CORDET Framework does not cover the reception of down-transfers.||||
6.13.3.4|Subservice observables|The following observables shall be defined for the on-board large packet downlink subservice: 1. the number of on-going downlinks; 2. the list of large message transaction identifiers associated to the on-going downlinks in an array of size corresponding to the maximum number of large packets that can be downlinked concurrently.|C1|See definition of Observable Data Items associated to service 13 in [PX-SP]||||
6.13.4.1a|Configuration of large packet uplink subservice|The maximum number of large packets that can be uplinked concurrently shall be declared when specifying the large packet uplink subservice.|C2|See statement of compliance to clause 6.13.3.1a.||||
b||The part size used by the large packet uplink subservice to decompose large packets shall be declared when specifying that subservice.|n.a.|The PUS Extension of the CORDET Framework does not cover the sending of up-transfer packets||||
c||The maximum time allocated to the uplink receiving entity for receiving a subsequent uplink part request after the reception of the previous one (uplink reception time-tout) shall be declared when specifying the large packet uplink subservice.|C2|The PUS Extension of the CORDET Framework does not implement any tme-out mechanism for uplink packets: uplink packets are processed when they are received. If needed, a time-out mechanism can be implemented by the host application which can use the up-transfer abort mechanism to abort the up-transfer in case of time-out violation.||||
6.13.4.2a|Resources|The resources allocated to the uplink receiving entity of the large packet uplink subservice to process large packets shall be declared when specifying the spacecraft architecture and its operations.|C2|See statement of compliance to clause 6.13.4.2a.||||
6.13.4.3.1a|Uplink Process|For each large packet that it processes, the sending entity of the large packet uplink subservice shall: 1. assign a unique large message transaction identifier to that large Packet; 2. split the large packet into parts; 3. associate to each part, a unique part sequence number; 4. encapsulate each part into a single uplink part request.|n.a.|The PUS Extension of the CORDET Framework does not cover the sending of up-transfer packets||||
b||Each part request shall contain: exactly one part instruction made of: (a) an identifier of whether the part request is the 'First' part, an 'Intermediate' part or the 'Last' part of the large packet; (b) the large message transaction identifier; (c) the part sequence number; (d) the part itself.|C1|See definition of the components encapsulating up-transfer packets (components LptUpFirstCmd, LptUpInterCmd and LptUpLastCmd)||||
c||The destination of the uplink part requests generated by the large packet uplink subservice shall be declared when specifying the space to ground architecture.|n.a.|The PUS Extension of the CORDET Framework does not cover the sending of up-transfer packets||||
d||The sending entity of the large packet uplink subservice shall generate the uplink part requests related to each large packet, in increasing order of part sequence number and at the highest frequency supported under the prevailing operation constraints.|n.a.|The PUS Extension of the CORDET Framework does not cover the sending of up-transfer packets||||
6.13.4.3.2a|Accepting uplink part requests and reconstructing large packets|The receiving entity of the large packet uplink subservice shall be able to process all uplink part requests that it receives.|C1|The PUS Extension of the CORDET Framework supports commands (13,9) to (13,11)||||
b||The receiving entity of the large packet uplink subservice shall initiate the uplink operation when it receives the request to uplink the first part of the large packet.|C1|Reception of a (13,9) triggers the transition of the LPT State Machine to state UP\_TRANSFER. This marks the start of the reception process.||||
c||The receiving entity of the large packet uplink subservice shall initiate the reception timer after the successful reception of the request to uplink the first part or the request to uplink an intermediate part.|C1|See definition of LPT State Machine||||
d||The receiving entity of the large packet uplink subservice shall end the uplink operation when the request to uplink the last part of the large packet has successfully been received.|C1|Reception of a (13,11) triggers the transition of the LPT State Machine from state UP\_TRANSFER to state INACTIVE. This marks the end of the reception process.||||
e||The receiving entity of the large packet uplink subservice shall abort the uplink operation when the reception timer reaches the uplink reception timeout.|C1|The expiration of the time-out triggers a transition of the LPT State Machine from state UP\_TRANSFER to state INACTIVE. This marks the end of the reception process.||||
f||The receiving entity of the large packet uplink subservice shall abort the uplink operation when a discontinuity is detected in the uplink reception sequence.|C1|Detection of a discontinuity triggers a transition of the LPT State Machine from state UP\_TRANSFER to state INACTIVE. This marks the end of the reception process.||||
g||For each uplink part request that is received, the receiving entity of the large packet uplink subservice shall include that part in the reconstruction process of the related large packet.|C1|See definition of Progress Action of LptUpFirstCmd, LptUpInterCmd and LptUpLastCmd components||||
h||Upon successful completion of the uplink operation, the receiving entity of the large packet uplink subservice shall: 1. generate that large packet for subsequent routing to its destination.|C1|This is done implicitly because the large packet is re-constructed in an LPT Buffer which is then available to the host application for further processing||||
I||For each large packet uplink that is aborted, the receiving entity of the large packet uplink subservice shall: 1. generate a single large packet uplink abortion notification that includes the reason of that abortion; 2. discard that large packet and the related uplink part requests.|C1|1. The PUS Extension supports report (13,16) to carry the notification of an up-transfe abort. 2. If the LPT State Machine is in state INACTIVE (which would be the case after an up-transfer has been aborted), all up-transfer commands are rejected with an acceptance check failure ||||
6.13.4.3.3a|Large packet uplink abortion report|The receiving entity of the large packet uplink shall provide the capability to generate large packet uplink abortion reports.|C1|The PUS Extension supports report (13,16) to carry the notification of an up-transfe abort. ||For each large packet uplink abortion notification that it generates, the receiving entity of the large packet uplink subservice shall generate a single large packet uplink abortion report that contains that notification.|C1|See definition of transition action from state UP\_TRANSFER to state INACTIVE for the LPT State Machine in response to an \texttt{AbortUpTransfer} command.
||Each large packet uplink abortion notification shall contain: 1. the large message transaction identifier; 2. the abortion reason.|C1|See definition of LptUpAbortRep component||||
6.13.4.4|Subservice Observables|The following observables shall be defined for the large packet uplink subservice: 1. the number of on-going uplinks; 2. the list of the large message transaction identifiers associated to the on-going uplinks in an array of size corresponding to the maximum number of large packets that can be uplinked Concurrently.|C1|See definition of Observable Data Items associated to service 13 in [PX-SP]||||
6.14|Real-Time Forwarding Control|Definition of service 14|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.15|On-Board Storage and Retrieval|Definition of service 15|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.17.2.1.1a|Test subservice|Each test service shall contain at least one test subservice.|C1|The PUS Extension of the CORDET Framework supports service 17 in full||||
6.17.2.2a|Application process|Each application process shall host at most one test subservice provider.|C1|An application instantiated from the CORDET Framework can only provide one instance of a service of a given type||||
6.17.3a|Perform an are-you-alive connection test|The test subservice shall provide the capability to perform an are-you-alive connection test.|C1|The PUS Extension of the CORDET Framework supports sub-types 1 and 2 of service 17||||
b||Each request to perform an are-you-alive connection test shall contain exactly one instruction to perform an are-you-alive connection test.|C1|Command (17,1) triggers one single are-you-alive test||||
c||For each valid instruction to perform an are-you-alive connection test, the test subservice shall generate a single are-you-alive connection test notification that notifies that the application process that hosts the test subservice is alive and has successfully received the request.|C1|The command (17,1) triggers generation of one single report (17,2)||||
d||For each valid request to perform an are-you-alive connection test, the test subservice shall generate a single are-you-alive connection test report that includes the related are-you-alive connection test notification.|C1|The command (17,1) triggers generation of one single report (17,2)||||
6.17.4.1a|Application process accessibility|The list of application processes for which the test subservice can perform an on-board connection testing shall be declared when specifying that subservice.|NA|This requirement does not concern the implementation of the services and is therefore outside the scope of the PUS Extension of the CORDET Framework||||
b||For each application process for which the test subservice can perform an on-board connection testing, the criteria for a successful on-board connection test between that application process and that service shall be declared when specifying that subservice.|NA|This requirement does not concern the implementation of the services and is therefore outside the scope of the PUS Extension of the CORDET Framework. In general, the success criterium for an are-you-alive test is that a (17,2) report be generated in response to a (17,1) command but applications may specify additional timing constraints.||||
6.17.4.2a|Perform an on-board connection test|The test subservice capability to perform an on-board connection test shall be declared when specifying that subservice.|NA|This requirement does not concern the implementation of the services and is therefore outside the scope of the PUS Extension of the CORDET Framework||||
b||Each request to perform an on-board connection test shall contain exactly one instruction to perform an on-board connection test.|C1|A command (17,3) contains triggers one single on-board connection test||||
c||Each instruction to perform an on-board connection test shall contain: the identifier of the application process that connection test is requested.|C1|See specification command (17,3)||||
d||The test subservice shall reject any request to perform an on-board connection test if: \newline 1. that request contains an instruction that refers to an application process that is not in the list of application processes for which the test subservice can perform an on-board connection testing.|C1|The start action of command (17,3) checks the legality of the target for the connection test and declares failure if this does not match an entry in a pre-defined list of application identifiers||||
e||For each request to perform an on-board connection test that is rejected, the test subservice shall generate a failed start of execution notification.|C1|See statement of compliance to previous requirement||||
f||For each valid instruction to perform an on-board connection test, the test subservice shall: \newline 1. perform a connection test with the application process referred to by that instruction; \newline 2. if the criteria for a successful on-board connection test with that application process are satisfied, generate a single on-board connection test notification that includes the identifier of the application process that connection has been tested. \newline 3. if the criteria for a successful on-board connection test with that application process are not satisfied, generate a failed completion of execution verification report.|C1|See progress action of command (17,3). The connection test is implemented as an Are-You-Alive test with the target application.||||
g||For each valid request to perform an on-board connection test, the test subservice shall generate a single on-board connection test report that includes the related on-board connection test notification.|C1|See progress action of command (17,3) and specification of report (17,4)||||
6.18|On-Board Control Procedure|Definition of service 18|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.19|Event-Action|Definition of service 19|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.2||Definition of service 20|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.21|Request Sequencing|Definition of service 21|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.22|Position-Based Scheduling|Definition of service 22|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
6.23|File Management|Definition of service 23|n.a.|This service is not yet supported by the PUS Extension of the CORDET Framework||||
7.3.1a|Packet field type code|Each packet field shall be associated to a packet field code that indicates the data type of any value carried by that packet field.|C2|The definition of the attributes of commands and reports is an adaptation point of the CORDET Framework (see adaptation points OCM-12 and ICM-21 in [CR-SP]). The definition of the syntactical types of these attributes is therefore done as part of the framework instantiation process.||||
b||Tailoring this Standard for a mission, for each new message type defined for that mission, the packet field type code of each field of that new message type shall be declared when specifying that message type.|C2|See justification of first requirement in this clause||||
c||Tailoring this Standard for a mission, for each message type field that packet field format code is unknown, the packet field format code of that field shall be declared when specifying the application process that uses the related message type.|C2|See justification of first requirement in this clause||||
d||The PTC specified in Table 7-1 shall be used to declare the PTC of each packet field.|C2|See justification of first requirement in this clause||||
e||The PTC of each packet field shall be declared when specifying the structure of each packet type.|C2|See justification of first requirement in this clause||||
7.3.2a|Booelan|Each packet field used to carry Boolean values shall be of PTC 1.|C2|See justification of first requirement in clause 7.3.1a||||
b||The PFCs specified in Table 7-2 shall be used for packet fields carrying Boolean values.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.3a|Enumerated|Each packet field used to carry Boolean values shall be of PTC 2.|C2|See justification of first requirement in clause 7.3.1a||||
b||The PFCs specified in Table 7-3 shall be used for packet fields carrying Boolean values.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.4a|Unsigned Integer|Each packet field used to carry Boolean values shall be of PTC 3.|C2|See justification of first requirement in clause 7.3.1a||||
b||Each unsigned integer value shall be encoded with Bit 0 being the most significant bit (MSB) and Bit NÂ­1 the least significant bit (LSB).|C2|See justification of first requirement in clause 7.3.1a||||
c||The PFCs specified in Table 7-4 shall be used for packet fields carrying unsigned integer values.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.5a|Signed Integer|Each packet field used to carry Boolean values shall be of PTC 4.|C2|See justification of first requirement in clause 7.3.1a||||
||Bit 0 of each signed integer parameter shall be used to determine the sign of the parameter value.|C2|See justification of first requirement in clause 7.3.1a||||
||The PFCs specified in Table 7-5 shall be used for packet fields carrying unsigned integer values.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.6a|Real|Each packet field used to carry Boolean values shall be of PTC 5.|C2|See justification of first requirement in clause 7.3.1a||||
||The PFCs specified in Table 7-6 shall be used for packet fields carrying Boolean values.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.7a|Bit-String|Each packet field used to carry Boolean values shall be of PTC 6.|C2|See justification of first requirement in clause 7.3.1a||||
b||The PFCs specified in Table 7-7 shall be used for packet fields carrying Boolean values.|C2|See justification of first requirement in clause 7.3.1a||||
c||The variableÂ­ length bitÂ­string shall have the structure specified in Figure 7-3.|C2|See justification of first requirement in clause 7.3.1a||||
d||For each application process that uses variable-length octet-strings, the PFC of the length field of the variable-length bit-string format shall be declared when specifying that application process.|C2|See justification of first requirement in clause 7.3.1a||||
e||Each spare field of a telemetry or a telecommand packet shall be of fixed-length PTC 6.|C2|See justification of first requirement in clause 7.3.1a||||
f||For each spare field of a telemetry or a telecommand packet, all bits of that field shall be set to zero.|C2|See justification of first requirement in clause 7.3.1a||||
g||For each packet field containing a fixed-length bit-string whose length is deduced, the definition used to deduce that length shall be declared when specifying the related packet field type.|C2|See justification of first requirement in clause 7.3.1a||||
h||For each packet field containing a fixed-length bit-string whose length is deduced, the deduction of the length shall only result from the content of one or more preceding fields of the same packet, of one or more mission constants or a combination of both.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.8a|Octet-String|Each packet field used to carry Boolean values shall be of PTC 7.|C2|See justification of first requirement in clause 7.3.1a||||
b||The PFCs specified in Table 7-8 shall be used for packet fields carrying Boolean values.|C2|See justification of first requirement in clause 7.3.1a||||
c||The variableÂ­ length octet-string shall have the structure specified in Figure 7-3.|C2|See justification of first requirement in clause 7.3.1a||||
d||For each application process that uses variable-length octet-strings, the PFC of the length field of the variable-length bit-string format shall be declared when specifying that application process.|C2|See justification of first requirement in clause 7.3.1a||||
e||For each packet field containing a fixed-length octet-string whose length is deduced, the definition used to deduce that length shall be declared when specifying the related packet field type.|C2|See justification of first requirement in clause 7.3.1a||||
f||For each packet field containing a fixed-length octet-string whose length is deduced, the deduction of the length shall only result from the content of one or more preceding fields of the same packet, of one or more mission constants or a combination of both.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.9a|Character-String|Each packet field used to carry character-string values shall be of PTC 8.|C2|See justification of first requirement in clause 7.3.1a||||
b||The values that character-string parameters can take shall be sequences of visible characters.|C2|See justification of first requirement in clause 7.3.1a||||
c||The PFCs specified in Table 7-9 shall be used for packet fields carrying character-string values.|C2|See justification of first requirement in clause 7.3.1a||||
d||The variableÂ­ length characterÂ­string format shall have the structure specified in Figure 7-5:|C2|See justification of first requirement in clause 7.3.1a||||
e||For each application process that uses variable-length character-strings, the PFC of the length field of the variable-length character-string format shall be declared when specifying that application process.|C2|See justification of first requirement in clause 7.3.1a||||
f||For each packet field containing a fixed-length character-string whose length is deduced, the definition used to deduce that length shall be declared when specifying the related packet field type.|C2|See justification of first requirement in clause 7.3.1a||||
g||For each packet field containing a fixed-length character-string whose length is deduced, the deduction of the length shall only result from the content of one or more preceding fields of the same packet, of one or more mission constants or a combination of both.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.10a|Absolute Time|Each packet field used to carry absolute time values shall be of PTC 9.|C2|See justification of first requirement in clause 7.3.1a||||
b||Each absolute time parameter value shall be a positive time offset that is a number of seconds and fractions of a second from a given epoch.|C2|See justification of first requirement in clause 7.3.1a||||
c||If the absolute time parameter has CDS format, the standard CCSDS epoch of 1958 January 1 shall be used.|C2|See justification of first requirement in clause 7.3.1a||||
d||The PFCs specified in Table 7-10 shall be used for packet fields carrying absolute time values.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.11a|Relative Time|Each packet field used to carry relative time values shall be of PTC 10.|C2|See justification of first requirement in clause 7.3.1a||||
b||Each relative time parameter value shall be a positive or a negative time offset that is the number of seconds and fractions of a second from the occurrence time of an event whose identification can be derived from other parameters in the packet (identifying a type of on-board event) or a number of seconds and fractions of a second between two absolute times.|C2|See justification of first requirement in clause 7.3.1a||||
c||The PFCs specified in Table 7-11 shall be used for packet fields carrying relative time values.|C2|See justification of first requirement in clause 7.3.1a||||
7.3.12a|Deduced|Each packet field whose structure and format is deduced shall be of PTC 11 PFC 0.|C2|See justification of first requirement in clause 7.3.1a||||
b||For each packet field whose structure and format is deduced, the definition used to deduce that structure and format shall be declared when specifying the related packet field type.|C2|See justification of first requirement in clause 7.3.1a||||
c||For each packet field whose structure and format is deduced, the deduction of the structure and format shall only result from the content of one or more preceding fields of the same packet, of one or more mission constants or a combination of both.|C2|See justification of first requirement in clause 7.3.1a||||
7.313a|Packet|Each packet field used to carry packets shall be of PTC 12.|C2|See justification of first requirement in clause 7.3.1a||||
b||The PFCs specified in Table 7-12 shall be used for packet fields carrying packets.|C2|See justification of first requirement in clause 7.3.1a||||
7.4.2|The CCSDS Space Packet|Once a telecommand or a telemetry packet has been generated by an application process, no one shall update that packet.|C1|The act of generating a packet in the CORDET Framework coincides with its being executed by its OutManager. After this execution is completed, the packet is handed over to the middleware through the OutStream and can no longer be accessed by the framework infrastructure.||||
7.4.3.1a|Telemetry packet secondary header|With the exception of the spacecraft time packets specified in clauses 6.9.4.2 and 6.9.4.3, all telemetry packets defined in this Standard shall have a telemetry packet secondary header.|C2|The PUS Extension of the CORDET Framework specifies the existence of a number of attributes (see section 4 of [PX-SP]) but their precise definition is done during the framework instantiation process.||||
b||Each telemetry packet secondary header shall have the structure specified in Figure 7-7.|C1/C2|See statement of compliance to the next requirements in this clause||||
c||Each application process shall set the TM packet PUS version number of each telemetry packet it generates to 2.|C2|This field does not exist in the CORDET Framework but, since its value is fixed, it can be added by applications when they implement the functions which fill in the header of their telemetry packets.||||
d||Each application process that provides the capability to report the spacecraft time reference status used when time tagging telemetry packets shall set the spacecraft time reference status field of each telemetry packet it generates to the status of the on-board time reference used when time tagging that telemetry packet.|C2|The value of this field is provisionally assumed to be zero. This may change after service 9 has been defined (TBC).||||
e||Each application process that does not provide the capability to report the status of the on-board time reference used when time tagging telemetry packets shall set the spacecraft time reference status field of each telemetry packet it generates to 0.|C2|See statement of compliance to previous requirement||||
f||For each report that it generates, each application process shall set the message type ID field of the corresponding telemetry packet to the message type identifier of that report.|C1|The CORDET Framework pre-defines the type and sub-type attribute which, taken together, constitute the message type.||||
g||For each report that it generates, each application process that provides the capability to count the type of generated messages per destination and report the corresponding message type counter shall set the message type counter of the related telemetry packet to the value of the related counter.|C1|The CORDET Framework maintains counters of messages generated for each [APID,Destination] pair but it does not, by default, provide the capability to count the number of generated messages of a given type.||||
h||Each application process that does not provide the capability to count the type of generated messages per destination and report the corresponding message type counter shall set the message type counter field of each telemetry packet it generates to 0.|C1/C2|This capability is, by default, not provided by the CORDET Framework and hence this field can be set to zero (unless an application decides to provide the capability at its own level)||||
I||Each application process shall set the destination ID field of each telemetry packet it generates to the application process user identifier of the application process addressed by the related report.|C1|See mapping of destination field in section 4 of [PX-SP].||||
j||The PFC of the time field of telemetry packets shall be declared when specifying the time service used by the spacecraft.|C2|See statement of compliance to clause 7.3.1a.||||
k||Each application process shall set the time field of each telemetry packet it generates to the time tag of the related report.|C1|The time-stamp of out-going components is set by the Send Packet Procedure of the OutComponent of the CORDET Framework (see section 6.1.1 of the CORDET Framework Definition Document).||||
l||For each application process, the presence and bit-size of the spare field of the telemetry packet secondary header shall be declared when specifying that application process.|C2|See statement of compliance to clause 7.3.1a.||||
7.4.3.2a|Telemetry User Data Field|Each telemetry user data field shall have the structure specified in Figure 7-8.|C2|See statement of compliance to clause 7.3.1a.||||
||The telemetry padding word size used by each application process shall be declared when specifying that application process.|C2|See statement of compliance to clause 7.3.1a.||||
||For each telemetry packet that it generates, each application process shall ensure that the total length of that packet is an integer multiple of the padding word size declared for that application process by including a user data spare field of the minimum bit-size that results in that integer multiple.|C2|See statement of compliance to clause 7.3.1a.||||
||Whether checksumming telemetry packets is used shall be declared when tailoring this standard to the mission.|NA|The CORDET Framework treats check-summing as a middleware-level function and therefore does not provide an interface for computing the check-sum of a packet.||||
||If checksumming telemetry packets is used for the mission, the type of checksum to use, that is either the ISO standard 16-bits checksum or the CRC standard 16-bits, shall be declared when tailoring this standard to the mission.|NA|See statement of compliance to previous requirement||||
||If checksumming telemetry packets is used for the mission, for each telemetry packet that it generates, each application process shall: \newline 1. calculate the checksum of that packet, and \newline 2. set the calculated value in the packet error control field of that packet.|NA|See statement of compliance to previous requirement||||
7.4.4.1a|Telecommand packet secondary header|With the exception of the CPDU command packet specified in clause 9, all telecommand packets defined in this Standard shall have a telecommand packet secondary header.|C2|The PUS Extension of the CORDET Framework specifies the existence of a number of attributes (see section 4 of [PX-SP]) but their precise definition is done during the framework instantiation process.||||
b||Each telecommand packet secondary header shall have the structure specified in Figure 7-9.|C1/C2|See statement of compliance to the next requirements in this clause||||
c||For each request that it issues, each application process shall set the TC packet PUS version number to 2.|C1|This field does not exist in the CORDET Framework and the framework ignores it.||||
d||For each request that it issues, each application process shall set: \newline the bit 3 of the acknowledgement flags field of the corresponding telecommand packet to: (a) 1 if the reporting of the successful acceptance of that request by the destination application process is requested (b) 0 otherwise; \newline the bit 2 of the acknowledgement flags field of the corresponding telecommand packet to: (a) 1 if successful start of execution of that request by the destination application process is requested; (b) 0 otherwise; \newline the bit 1 of the acknowledgement flags field of the corresponding telecommand packet to: (a) 1 if the reporting of the successful progresses of execution of that request by the destination application process is requested; (b) 0 otherwise; \newline the bit 0 of the acknowledgement flags field of the corresponding  telecommand packet to: (a) 1 if the reporting of the successful completion of execution of the related request by the destination application process is requested; (b) 0 otherwise.|C1|The CORDET Framework defines acknowledge flags for commands with the same semantics as the PUS (see section 4 of [PX-SP]).||||
e||For each request that it issues, each application process shall set the message type ID field of the corresponding telecommand packet to the message type identifier of that request.|C1|The CORDET Framework pre-defines the type and sub-type attribute which, taken together, constitute the message type.||||
f||For each request that it issues, each application process shall set the source ID field to its source identifier.|C1|See mapping of source field in section 4 of [PX-SP].||||
g||For each application process that issues requests, the presence and bit-size of the spare field of the telecommand packet secondary header shall be declared when specifying that application process.|C2|See statement of compliance to clause 7.3.1a.||||
7.4.4.2a|Telecommand User Data Field|Each telecommand user data field shall have the structure specified in Figure 7-10.|C2|See statement of compliance to clause 7.3.1a.||||
b||The telecommand padding word size used for each application process shall be declared when specifying that application process.|C2|See statement of compliance to clause 7.3.1a.||||
c||For each telecommand packet that it generates, each application process shall ensure that the total length of that packet is an integer multiple of the padding word size declared for that application process, by including a user data spare field of the minimum bit-size that results in that integer multiple.|C2|See statement of compliance to clause 7.3.1a.||||
d||The type of checksum to use for checksumming all telecommand packets, which is either the ISO standard 16-bits checksum or the CRC standard 16-bits checksum, shall be declared when tailoring this standard to the mission.|C2|See statement of compliance to clause 7.3.1a.||||
||For each telecommand packet that it generates, each application process shall: \newline 1. calculate the checksum of that packet, and \newline 2. set the calculated value in the packet error control field of that packet.||||||
